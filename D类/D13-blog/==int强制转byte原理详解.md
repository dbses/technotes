# 一、背景

今天在看 MongoDB 的 ObjectId 源码时，发现有如下代码：

```java
public void putToByteBuffer(ByteBuffer buffer) {
    // int timestamp = 1658385462
    buffer.put(int3(timestamp));
    buffer.put(int2(timestamp));
    buffer.put(int1(timestamp));
    buffer.put(int0(timestamp));
    buffer.put(int2(machineIdentifier));
    buffer.put(int1(machineIdentifier));
    buffer.put(int0(machineIdentifier));
    buffer.put(short1(processIdentifier));
    buffer.put(short0(processIdentifier));
    buffer.put(int2(counter));
    buffer.put(int1(counter));
    buffer.put(int0(counter));
}
```

```java
private static byte int2(int x) {
    return (byte) (x >> 16);
}
```

即：`(byte) 1658385462 >> 16`的结果为`-40`。

于是想深究其中的原理。

# 二、原码、反码、补码

## 2.1 什么是原码、反码、补码？

原码：原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值。

反码：正数的反码是其本身。负数的反码是在其原码的基础上, 符号位不变，其余各个位取反。

补码：正数的补码就是其本身。负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1。

从原码、反码、补码的表示方式不难看出，原码才是人眼最直观能看出值的表示方式，那么为什么还要有反码和补码呢？

答案是为了简化计算机集成电路的设计。

首先， 因为人脑可以知道第一位是符号位,，在计算的时候我们会根据符号位,，选择对真值区域的加减。但是对于计算机,，加减乘数已经是最基础的运算,，要设计的尽量简单.。计算机辨别"符号位"显然会让计算机的基础电路设计变得十分复杂，于是人们想出了将符号位也参与运算的方法。

我们知道, 根据运算法则减去一个正数等于加上一个负数, 即: 1-1 = 1 + (-1) = 0 , 所以机器可以只有加法而没有减法,这样计算机运算的设计就更简单了。此外，由于现阶段计算机CPU擅长做加法运算，CPU硬件实现减法要复杂得多，而且运算效率很低，所以我们偷懒只讨论加法运算。说不定以后发明了减法加速硬件，那就另当别论了。

## 2.2 为什么要有反码？

于是人们开始探索将符号位参与运算，并且只保留加法的方法。 首先来看原码: 计算十进制的表达式: 1-1=0。

```
1 - 1 = 1 + (-1) = [00000001]原 + [10000001]原 = [10000010]原 = -2
```

如果用原码表示, 让符号位也参与计算，显然对于减法来说， 结果是不正确的。这也就是为何计算机内部不使用原码表示一个数。

为了解决原码做减法的问题, 出现了反码：

```
1 - 1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原= [0000 0001]反 + [1111 1110]反 = [1111 1111]反 = [1000 0000]原 = -0
```

发现用反码计算减法, 结果的真值部分是正确的。

## 2.3 为什么要有补码？

用反码计算减法， 结果的真值部分是正确的。而唯一的问题其实就出现在"0"这个特殊的数值上。 虽然人们理解上+0和-0是一样的， 但是0带符号是没有任何意义的。 而且会有[0000 0000]原和[1000 0000]原两个编码表示0。

于是补码的出现,，解决了0的符号以及两个编码的问题：

```
1-1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原 = [0000 0001]补 + [1111 1111]补 = [0000 0000]补 = [0000 0000]原
```

这样 0 用 [0000 0000] 表示, 而以前出现问题的 -0 则不存在了，而且可以用 [1000 0000] 表示 -128：

```
(-1) + (-127) = [1000 0001]原 + [1111 1111]原 = [1111 1111]补 + [1000 0001]补 = [1000 0000]补
```

-1-127的结果应该是-128， 在用补码运算的结果中，[1000 0000]补 就是-128。

但是注意：因为实际上是使用以前的-0的补码来表示-128, 所以-128并没有原码和反码表示。(对-128的补码表示`[1000 0000]补`算出来的原码是`[0000 0000]原`，这是不正确的)。

使用补码，不仅仅修复了0的符号以及存在两个编码的问题， 而且还能够多表示一个最低数。这就是为什么8位二进制，使用原码或反码表示的范围为[-127, +127]，而使用补码表示的范围为[-128, 127]。

# 三、int 强制转 byte

1. 首先，计算机要将 1658385462 转换为二进制数，因为 int 为 4 字节 32 位，所以，二进制转换如下：

```
0110 0010 1101 1000 1111 0100 0011 0110 >> 16 = 0110 0010 1101 1000
```

2. 因为计算机存储补位，将其转为补位：

```
0110 0010 1101 1000
```

3. 因为 byte 为 1 字节 8 位，所以强制转换时计算机只保留其后 8 位，即为：1101 1000。
4. 此时为补位，要展示给用户需转换成原位：

```
补：1101 1000
反：1101 0111
原：1010 1000
```

5. 最高位 1 表示负数，将 010 1000 转换成十进制数，则为 -40。

> 参考资料：
>
> https://blog.csdn.net/ch717828/article/details/103315407<br>
> https://blog.csdn.net/lanqian2020/article/details/104685439

