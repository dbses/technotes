# 学习分享（第 2 期）：从源码层面看 Redis 是如何巧妙节省内存的

## 回顾

文章[《Redis 的 String 类型，原来这么占内存》](https://mp.weixin.qq.com/s/jRoZdFExGvASvb8HRQL6kA)



## 一、redisObject

下面的代码展示了 redisObject 结构体的定义：

```c
typedef struct redisObject {
    unsigned type:4; //redisObject的数据类型，4个bits
    unsigned encoding:4; //redisObject的编码类型，4个bits
    unsigned lru:LRU_BITS; //redisObject的LRU时间，LRU_BITS为24个bits
    int refcount; //redisObject的引用计数，4个字节
    void *ptr; //指向值的指针，8个字节
} robj;
```

`server.h` 文件定义了 `LRU_BITS`。

```
#define LRU_BITS 24
```

从代码中我们可以看到，在 type、encoding 和 lru 三个变量后面都有一个冒号，并紧跟着一个数值，表示该元数据占用的比特数。这种变量后使用冒号和数值的定义方法，实际上是 C 语言中的位域定义方法，可以用来有效地节省内存开销。

这种方法比较适用的场景是，当一个变量占用不了一个数据类型的所有 bits 时（type 这个变量占用不了 redisObject 所有的 bits），就可以使用位域定义方法，把一个数据类型中的 bits（32 bits），划分成多个（3 个）位域，每个位域占一定的 bit 数。这样一来，一个数据类型的所有 bits 就可以定义多个变量了，从而也就有效节省了内存开销。

## 二、SDS 的嵌入式字符串设计

SDS 设计了不同类型的结构头，包括 sdshdr8、sdshdr16、sdshdr32 和 sdshdr64。这些不同类型的结构头可以适配不同大小的字符串，从而避免了内存浪费。

SDS 在保存比较小的字符串时，会使用嵌入式字符串的设计方法，将字符串直接保存在 redisObject 结构体中。然后在 redisObject 结构体中，存在一个指向值的指针 ptr，而一般来说，这个 ptr 指针会指向值的数据结构。

以创建一个 String 类型的值为例，Redis 会调用 createStringObject 函数， 来创建相应的 redisObject，而这个 redisObject 中的 ptr 指针，就会指向 SDS 数据结构，如下图所示。

![image-20230124112231454](https://technotes.oss-cn-shenzhen.aliyuncs.com/2023/image-20230124112231454.png)

在 Redis 源码中，createStringObject 函数会根据要创建的字符串的长度，决定具体调用哪个函数来完成创建。

这部分的代码在 xx 文件中：

```c
#define OBJ_ENCODING_EMBSTR_SIZE_LIMIT 44
robj *createStringObject(const char *ptr, size_t len) {
    //创建嵌入式字符串，字符串长度小于等于44字节
    if (len <= OBJ_ENCODING_EMBSTR_SIZE_LIMIT)
        return createEmbeddedStringObject(ptr,len);
    //创建普通字符串，字符串长度大于44字节
    else
        return createRawStringObject(ptr,len);
}
```

![image-20230124112804683](https://technotes.oss-cn-shenzhen.aliyuncs.com/2023/image-20230124112804683.png)

当 len 的长度大于 `OBJ_ENCODING_EMBSTR_SIZE_LIMIT` （默认为 44 字节）这个宏定义时， `createStringObject` 函数会调用 `createRawStringObject` 函数，否则就调用 `createEmbeddedStringObject` 函数。

> `createEmbeddedStringObject` 嵌入式字符串

对于 `createRawStringObject` 函数来说，它在创建 String 类型的值的时候，会调用 `createObject` 函数。在调用 `createObject` 函数时，会传递 `OBJ_STRING` 类型，表示要创建 String 类型的对象，以及传递指向 SDS 结构的指针，如以下代码所示。

```c
robj *createRawStringObject(const char *ptr, size_t len) {
    return createObject(OBJ_STRING, sdsnewlen(ptr,len));
}
```

`createObject` 函数主要是用来创建 Redis 的数据对象的，比如 String、List、Hash 等。该函数有两个参数，一个是用来表示所要创建的数据对象类型，另一个是指向数据对象的指针。

```c
robj *createObject(int type, void *ptr) {
    //给redisObject结构体分配空间
    robj *o = zmalloc(sizeof(*o));
    //设置redisObject的类型
    o->type = type;
    //设置redisObject的编码类型，此处是OBJ_ENCODING_RAW，表示常规的SDS
    o->encoding = OBJ_ENCODING_RAW;
    //直接将传入的指针赋值给redisObject中的指针。
    o->ptr = ptr;
    o->refcount = 1;
    …
    return o;
}
```

也就是说，在创建普通字符串时，Redis 需要分别给 `redisObject` 和 SDS 分别分配一次内存，这样就既带来了内存分配开销，同时也会导致内存碎片。因此，当字符串小于等于 44 字节时，Redis 就使用了嵌入式字符串的创建方法，以此减少内存分配和内存碎片。

那么下面，我们就来具体看看，`createEmbeddedStringObject` 函数是如何把 `redisObject` 和 SDS 放置在一起的。总体来说，分为下面五步。

首先，`createEmbeddedStringObject` 函数会分配一块连续的内存空间，这块内存空间的大小等于 `redisObject` 结构体的大小 + `SDS` 结构头 `sdshdr8` 的大小 + 字符串大小的总和， 并且再加上 1 字节。

![image-20230124114812115](https://technotes.oss-cn-shenzhen.aliyuncs.com/2023/image-20230124114812115.png)

这里最后的 1 字节是 SDS 中加在字符串最后的结束字符“\0”。

口说无凭，我们看代码：

```c
robj *o = zmalloc(sizeof(robj) + sizeof(struct sdshdr8) + len + 1);
```

第二步、第三步

在分配了内存空间之后，就会创建 SDS 结构的指针 sh，并把 sh 指向这块连续空间中 SDS 结构头所在的位置，下面的代码显示了这步操作。

```c
struct sdshdr8 *sh = (void*)(o+1);
```

o 是 redisObject 结构体的变量，o+1 表示将内存地址从变量 o 开始移动一段距离，而移动的距离等于 redisObject 这个结构体的大小。

经过这步操作后，sh 指向的位置就如下图所示：

![image-20230124115928447](https://technotes.oss-cn-shenzhen.aliyuncs.com/2023/image-20230124115928447.png)

第四步

createEmbeddedStringObject 函数会把 redisObject 中的指针 ptr，指向 SDS 结构中的字符数组。

如以下代码所示，其中 sh 是刚才介绍的指向 SDS 结构的指针，属于 sdshdr8 类型。而 sh+1 表示把内存地址从 sh 起始地址开始移动一定的大小，移动的距离等于 sdshdr8 结构体的大小。

```c
o->ptr = sh+1;
```

这步操作完成后，redisObject 结构体中的指针 ptr 的指向位置就如下图所示，它会指向 SDS 结构头的末尾，同时也是字符数组的起始位置：

![](https://technotes.oss-cn-shenzhen.aliyuncs.com/2023/image-20230124120230852.png)

最后，createEmbeddedStringObject 函数会把参数中传入的指针 ptr 指向的字符串，拷贝到 SDS 结构体中的字符数组，并在数组最后添加结束字符。这部分代码如下所示：

```c
memcpy(sh->buf,ptr,len);
sh->buf[len] = '\0';
```

总之，你可以记住，Redis 会通过设计实现一块连续的内存空间，把 redisObject 结构体和 SDS 结构体紧凑地放置在一起。这样一来，对于不超过 44 字节的字符串来说，就可以避免内存碎片和两次内存分配的开销了。

而除了嵌入式字符串之外，Redis 还设计了压缩列表和整数集合，这也是两种紧凑型的内存数据结构，所以下面我们再来学习下它们的设计思路。

## 三、压缩列表的设计

压缩列表本身就是一块连续的内存空间，它通过使用不同的编码来保存数据。

这里为了方便理解压缩列表的设计与实现，我们先来看看它的创建函数 ziplistNew，如下所示：

```c
unsigned char *ziplistNew(void) {
    //初始分配的大小
    unsigned int bytes = ZIPLIST_HEADER_SIZE+ZIPLIST_END_SIZE;
    unsigned char *zl = zmalloc(bytes);
    …
    //将列表尾设置为ZIP_END
    zl[bytes-1] = ZIP_END;
    return zl;
}
```

ziplistNew 函数的逻辑很简单，就是创建一块连续的内存空间，大小为 ZIPLIST_HEADER_SIZE 和 ZIPLIST_END_SIZE 的总和，然后再把该连续空间的最后一个字节赋值为 ZIP_END，表示列表结束。

另外，在上面代码中定义的三个宏 ZIPLIST_HEADER_SIZE、 ZIPLIST_END_SIZE 和 ZIP_END，在 ziplist.c 中也分别有定义，分别表示 ziplist 的列表头 大小、列表尾大小和列表尾字节内容，如下所示。

```c
//ziplist的列表头大小，包括2个32 bits整数和1个16bits整数，分别表示压缩列表的总字节数，列表最后一个元素离列表头的偏移，以及列表中的元素个数
#define ZIPLIST_HEADER_SIZE (sizeof(uint32_t)*2 + sizeof(uint16_t))
//ziplist的列表尾大小，包括1个8 bits整数，表示列表结束。
#define ZIPLIST_END_SIZE (sizeof(uint8_t))
//ziplist的列表尾字节内容
#define ZIP_END 255
```

那么，在创建一个新的 ziplist 后，该列表的内存布局就如下图所示。注意，此时列表中还没有实际的数据。

![](https://technotes.oss-cn-shenzhen.aliyuncs.com/2023/image-20230124205849412.png)

然后，当我们往 ziplist 中插入数据时，ziplist 就会根据数据是字符串还是整数，以及它们的大小进行不同的编码。这种根据数据大小进行相应编码的设计思想，正是 Redis 为了节省内存而采用的。

那么，ziplist 是如何进行编码呢？要学习编码的实现，我们要先了解 ziplist 中列表项的结构。

ziplist 列表项包括三部分内容，分别是前一项的长度（prevlen）、当前项长度信息的编 码结果（encoding），以及当前项的实际数据（data）。下面的图展示了列表项的结构 （图中除列表项之外的内容分别是 ziplist 内存空间的起始和尾部）。

![image-20230124210043923](https://technotes.oss-cn-shenzhen.aliyuncs.com/2023/image-20230124210043923.png)

而为了方便查找，每个列表项中都会记录前一项的长度。因为每个列表项的长度不一样， 所以如果使用相同的字节大小来记录 prevlen，就会造成内存空间浪费。

举个例子，假设我们统一使用 4 字节记录 prevlen，如果前一个列表项只是一个字符串“redis”，长度为 5 个字节，那么我们用 1 个字节（8 bits）就能表示 0~256 字节长度 （2 的 8 次方等于 256）的字符串了。此时，prevlen 用 4 字节记录，其中就有 3 字节是浪费掉了。

ziplist 在对 prevlen 编码时，会先调用 `zipStorePrevEntryLength` 函数，用于判断前一个列表项是否小于 254 字节。如果是的话，那么 prevlen 就使用 1 字节表示；否则，`zipStorePrevEntryLength` 函数就调用 `zipStorePrevEntryLengthLarge` 函数进一步编码。这部分代码如下所示：

```c
//判断prevlen的长度是否小于ZIP_BIG_PREVLEN，ZIP_BIG_PREVLEN等于254
if (len < ZIP_BIG_PREVLEN) {
    //如果小于254字节，那么返回prevlen为1字节
    p[0] = len;
    return 1;
} else {
    //否则，调用zipStorePrevEntryLengthLarge进行编码
    return zipStorePrevEntryLengthLarge(p,len);
}
```

`zipStorePrevEntryLengthLarge` 函数会先将 prevlen 的第 1 字节设置为 254，然后使用内存拷贝函数 memcpy，将前一个列表项的长度值拷贝至 prevlen 的第 2 至第 5 字节。最后，`zipStorePrevEntryLengthLarge` 函数返回 prevlen 的大小，为 5 字节。

```c
if (p != NULL) {
    //将prevlen的第1字节设置为ZIP_BIG_PREVLEN，即254
    p[0] = ZIP_BIG_PREVLEN;
    //将前一个列表项的长度值拷贝至prevlen的第2至第5字节，其中sizeof(len)的值为4
    memcpy(p + 1, &len, sizeof(len));
    …
}
//返回prevlen的大小，为5字节
return 1 + sizeof(len);
```

好，在了解了 prevlen 使用 1 字节和 5 字节两种编码方式后，我们再来学习下 encoding 的编码方法。

所以，ziplist 在 `zipStoreEntryEncoding` 函数中，针对整数和字符串，就分别使用了不同字节长度的编码结果。下面的代码展示了 `zipStoreEntryEncoding` 函数的部分代码，你可以看到当数据是不同长度字符串或是整数时，编码结果的长度 len 大小不同。

```c
//默认编码结果是1字节
unsigned char len = 1;
//如果是字符串数据
if (ZIP_IS_STR(encoding)) {
    //如果字符串长度小于等于63字节（16进制为0x3f）
    if (rawlen <= 0x3f) {
        //默认编码结果是1字节
        …
    }
    //字符串长度小于等于16383字节（16进制为0x3fff）
    else if (rawlen <= 0x3fff) {
        //编码结果是2字节
        len += 1;
        …
    }
    //字符串长度大于16383字节
    else {
        //编码结果是5字节
        len += 4;
        …
    }
} else {
    /* 如果数据是整数，编码结果是1字节 */
    if (!p) return len;
    ...
}
```

简而言之，针对不同长度的数据，使用不同大小的元数据信息（prevlen 和 encoding）， 这种方法可以有效地节省内存开销。

## 参考资料

- 极客时间《Redis源码剖析与实战》

## 相关文章

也许你对下面文章也感兴趣。

- [Redis 高可用之哨兵机制实现细节](https://mp.weixin.qq.com/s/phU5BzyyG5Wxvw0sqkkK4A)
- [Redis 高可用全景一览](https://mp.weixin.qq.com/s/tsH45bpwc_WCSzi-wnRDbA)
- [海量数据下，如何统计用户的签到信息？](https://mp.weixin.qq.com/s/vcdmfZljCiv5ICJaRkvAAA)