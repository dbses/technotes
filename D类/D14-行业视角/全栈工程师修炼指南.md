# 导读 | 如何学习这个专栏？

# 学习路径 | 怎样成为一名优秀的全栈工程师？

**怎样修炼全栈技术？**

- 首先，我想说的是，**先成为合格的工程师，再谈全栈**。
- 其次，**在获取知识的基础上思考，尤其是从比较中思考**。
- 最后，**请不要忽视实践的力量**。

**专栏内容是怎样设计的？**

专栏的主要目的是介绍原理、分享认识、探讨观点、串联知识，并引发思考，带给你进一步学习和实践的机会，而不是完全一步一步教导具体怎么做。

- **内容广度：我会选择每个核心领域的代表性技术来介绍。**
- **内容深度：我会把深度控制在合适的位置，让入门到进阶的工程师都有收获。**

专栏包含网络协议和 Web 接口，MVC 架构相关，前端技术，持久层技术和最佳实践等几大章，这些内容会覆盖到基于 Web 的全栈技术最核心的部分。最后还有一章是综合性、自恰性强的专题，比如网站的性能优化、分页技术等。

# 01 | 网络互联的昨天、今天和明天：HTTP 协议的演化

# 02 | 为HTTP穿上盔甲：HTTPS

# ==第三章 从后端到前端==

# 14 | 别有洞天：从后端到前端

今天我们将迈入第三大基于 Web 的全栈技能领域——前端。

**为什么要学习前端技术？**

首先，它可以帮助你开阔眼界，为你的思维模式带来新的选项，整个全栈技术都有这样的特点，但是前端技术在这方面尤其明显。前端技术的结构和软件其它领域有着显著的不同，技术发展极其迅速，技术之水深不见底，开源社区百花齐放。

其次，它可以帮助你形成快速原型、即时验证和独立展示演示的优势，在迅捷的反馈中设计和编程。

再次，它可以帮助你建立产品思维。有人认为它能用来解决用户的核心问题，但实际上往往不是，解决核心问题主要还是靠后端的代码，但是前端的代码却是和用户最贴近和交互的部分，一个优秀的前端工程师总是具备非常强烈的产品属性。

最后，前端技术是全栈工程的必备技能。

**思维模式的转变**

如果你具备后端开发的经验，刚刚开始从后端转向前端，你可能会发现，有很多想当然的理解，不再适用，有很多想当然的解决方法，也不再有效。

1. 应用事件驱动编程

来看这样一段 JavaScript 代码：

```javascript
console.log("1");
 
setTimeout(function timeout() {
    console.log("2");
}, 0);
 
setTimeout(function timeout() {
    console.log("3");
}, 5000);
 
console.log("4");
```

你觉得打印结果应该是什么？是 1 -> 2 -> 4 -> 3 吗？在 Chrome 中，我们得到的结果如下：

```
1
4
undefined
2
3
```

这是为什么，上面的 undefined 又是什么？

为了回答上面的问题，我们需要了解 JavaScript 执行机制中的 Event Loop（事件循环）来理解上面的代码。

浏览器中 JavaScript 代码的执行通常是单线程的（对于 [Web Worker](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers) 这样的“例外”我们暂不讨论）——一个线程，一个调用栈，一次只做一件事。

具体说来，在整个 JavaScript 的世界里，引起代码运行的行为是通过事件驱动的，并且**全部是通过这唯一的一个勤奋的工作线程来执行的。那么当有事件产生的时候，这个工作线程不一定空闲，这就需要一个机制来让新产生的事件排队“等一等”**，等当前的工作完成之后，再来处理它。这个机制就是 Event Loop，这个等一等的事件，就被放在一个被称为事件（回调）队列的数据结构中。

于是上面的代码，实际在运行的时候，从事件队列的角度看，是这样的：

![image-20240113230928355](https://technotes.oss-cn-shenzhen.aliyuncs.com/2023/202401132309475.png)

工作线程不断地从整个事件队列的右侧取得新的事件来处理执行，而新的事件只会从左侧放入。主代码最先被执行，从上往下顺序执行，因此顺序是：

- 先打印 1；
- 在遇到第一个 setTimeout 的时候，告知浏览器，请在 0 秒之后往事件队列内放入执行打印 2 的事件；
- 在遇到第二个 setTimeout 的时候，告知浏览器，请在 5 秒之后往事件队列内放入执行打印 3 的事件；
- 再打印 4；
- 主代码执行完毕，Chrome 的控制台打印这段代码的返回值，但因为它没有返回值，于是就打印 undefined。

浏览器老老实实地按照要求放入了打印 2 的事件，虽然是第 0 秒就放入，但是因为放入的时候主代码还在执行，因此只能等待，它等到主代码执行完毕后才得到执行，打印了 2。

5 秒钟后，浏览器按照要求往队列里放入了打印 3 的事件，于是 3 被打印出来。

通过这种方式，JavaScript 可以让不同的任务在一个线程中完成，而整个任务编排的机制，**从代码的角度看，所有的逻辑都是通过七七八八的“异步回调”来完成的；而从程序员思维方式的角度看，以往基于线程的编程，变成了事件驱动的编程**。

另外，需要说明的是，浏览器的 JavaScript 执行是单线程的，但不代表浏览器是单线程的。浏览器通常还包含其它线程，比如说：

- 界面（GUI）渲染线程，这个线程的执行和上述的 JavaScript 工作线程是互斥的，即二者不可同时执行；
- 事件触发线程，这个也很好理解，我们介绍过有一个神秘人物帮着往队列中放入事件（例子中的回调打印 2 和回调打印 3），这个神秘人物就是事件触发线程。

2. 学写声明式代码
3. 培养交互思维

# 15 | 重剑无锋，大巧不工：JavaScript面向对象

首先，我们将通过面向对象的三大特征，结合实例，介绍 JavaScript 面向对象的知识：封装、继承以及多态。

**1. 封装**

在面向对象编程中，封装（Encapsulation）说的是一种通过接口抽象将具体实现包装并隐藏起来的方法。具体来说，封装的机制包括两大部分：

- 限制对对象内部组件直接访问的机制；
- 将数据和方法绑定起来，对外提供方法，从而改变对象状态的机制。

```javascript
function Book(name) {
    this.getName = () => {
        return name;
    };
    this.setName = (newName) => {
        name = newName;
    };
}
let book = new Book("Life");
book.setName("Time");
console.log(book.getName()); // Time
console.log(book.name); // 无法访问私有属性 name 的值
```

**2. 继承**

在面向对象编程中，继承（Inheritance）指的是一个对象或者类能够自动保持另一个对象或者类的实现的一种机制。我们经常讲的子类具备父类的所有特性，只是继承中的一种，叫做类继承；其实还有另一种，对象继承，这种继承只需要对象，不需要类。

在 ES6 以前，没有继承（extends）关键字，JavaScript 最常见的继承方式叫做**原型链继承**。原型（prototype）是 JavaScript 函数的一个内置属性，指向另外的一个对象，而那个对象的所有属性和方法，都会被这个函数的所有实例自动继承。

```javascript
function Base(name) {
    this.name = name;
}
function Child(name) {
    this.name = name;
}
Child.prototype = new Base();
 
var c = new Child("Life");
console.log(c.name); // "Life"
console.log(c instanceof Base); // true
console.log(c instanceof Child); // true
```

**3. 多态**

在面向对象编程中，多态（Polymorphism）指的是同样的接口，有着不同的实现。在 JavaScript 中没有用来表示接口的关键字，但是通过在不同实现类中定义同名的方法，我们可以轻易做到多态的效果，即同名方法在不同的类中有不同的实现。而由于没有类型和参数的强约束，它的灵活性远大于 Java 等静态语言。

# 16 | 百花齐放，百家争鸣：前端MVC框架

# 17 | 不一样的体验：交互设计和页面布局

# ==第四章 数据持久化==

# 21 | 赫赫有名的双刃剑：缓存（上）

**缓存应用模式**

在 Web 应用中，缓存的应用是有一些模式的，而我们可以归纳出这些模式以比较的方式来学习，了解其优劣，从而在实际业务中可以合理地使用它们。

1. Cache-Aside

这是最常见的一种缓存应用模式，整个过程也很好理解。数据获取策略：

- 应用先去查看缓存是否有所需数据；
- 如果有，应用直接将缓存数据返回给请求方；
- 如果没有，应用执行原始逻辑，例如查询数据库得到结果数据；
- 应用将结果数据写入缓存

![image-20240114223636494](https://technotes.oss-cn-shenzhen.aliyuncs.com/2023/202401142236622.png)

我们见到的多数缓存，基本上都是按照这种方式来配置和使用的。

数据读取的异常情形：

- 如果数据库读取异常，直接返回失败，没有数据不一致的情况发生；
- 如果数据库读取成功，但是缓存写入失败，那么下一次同一数据的访问还将继续尝试写入，因此这时也没有不一致的情况发生。

可见，这两种异常情形都是“安全”的。

数据更新策略：

- 应用先更新数据库；
- 应用再令缓存失效。

这里，避免踩坑的关键点有两个：

数据更新的这个策略，通常来说，**最重要的一点是必须先更新数据库**，而不是先令缓存失效，即这个顺序不能倒过来。原因在于，如果先令缓存失效，那么在数据库更新成功前，如果有另外一个请求访问了缓存，发现缓存数据库已经失效，于是就会按照数据获取策略，从数据库中使用这个已经陈旧的数值去更新缓存中的数据，这就导致这个过期的数据会长期存在于缓存中，最终导致数据不一致的严重问题。

这里我画了一张图，可以帮你理解，如果先令缓存失效，再更新数据库，为什么会导致问题：

![image-20240114224723031](https://technotes.oss-cn-shenzhen.aliyuncs.com/2023/202401142247089.png)

第二个关键点是，**数据库更新以后，需要令缓存失效，而不是更新缓存为数据库的最新值。**为什么呢？你想一下，如果两个几乎同时发出的请求分别要更新数据库中的值为 A 和 B，如果结果是 B 的更新晚于 A，那么数据库中的最终值是 B。但是，如果在数据库更新后去更新缓存，而不是令缓存失效，那么缓存中的数据就有可能是 A，而不是 B。因为数据库虽然是“更新为 A”在“更新为 B”之前发生，但如果不做特殊的跨存储系统的事务控制，缓存的更新顺序就未必会遵从“A 先于 B”这个规则，这就会导致这个缓存中的数据会是一个长期错误的值 A。

这张图可以帮你理解，如果是更新缓存为数据库最新值，而不是令缓存失效，为什么会产生问题：

![image-20240114224916323](https://technotes.oss-cn-shenzhen.aliyuncs.com/2023/202401142249408.png)

如果是令缓存失效，这个问题就消失了。因为 B 是后写入数据库的，那么在 B 写入数据库以后，无论是写入 B 的请求让缓存失效，还是并发的竞争情形下写入 A 的请求让缓存失效，缓存反正都是失效了。那么下一次的访问就会从数据库中取得最新的值，并写入缓存，这个值就一定是 B。

这两个关键点非常重要，而且不当使用引起的错误还非常常见。

数据更新的异常情形：

- 如果数据库操作失败，那么直接返回失败，没有数据不一致的情况发生；
- 如果数据库操作成功，但是缓存失效操作失败，这个问题很难发生，但一旦发生就会非常麻烦，缓存中的数据是过期数据，需要特殊处理来纠正。

2. Read-Through

这种情况下缓存系统彻底变成了它身后数据库的代理，二者成为了一个整体，应用的请求访问只能看到缓存的返回数据，而数据库系统对它是透明的。

![image-20240114224042325](https://technotes.oss-cn-shenzhen.aliyuncs.com/2023/202401142240393.png)

有的框架提供的内置缓存，例如一些 ORM 框架，就是按这种 Read-Through 和 Write-Through 来实现的。

数据获取策略：

- 应用向缓存请求数据；
- 如果缓存中有数据，返回给应用，应用再将数据返回；
- 如果没有，缓存查询数据库，并将结果写入自己；
- 缓存将数据返回给应用。

数据读取异常的情况分析和 Cache-Aside 类似，没有数据不一致的情况发生。

3. Write-Through

和 Read-Through 类似，图示同上，但 Write-Through 是用来处理数据更新的场景。

数据更新策略：

- 应用要求缓存更新数据；
- 如果缓存中有对应数据，先更新该数据；
- 缓存再更新数据库中的数据；
- 缓存告知应用更新完成。

这里的一个关键点是，**缓存系统需要自己内部保证并发场景下，缓存更新的顺序要和数据库更新的顺序一致。**比如说，两个请求分别要把数据更新为 A 和 B，那么如果 B 后写入数据库，缓存中最后的结果也必须是 B。这个一致性可以用乐观锁等方式来保证。

数据更新的异常情形：

- 如果缓存更新失败，直接返回失败，没有数据不一致的情况发生；
- 如果缓存更新成功，数据库更新失败，这种情况下需要回滚缓存中的更新，或者干脆从缓存中删除该数据。

4. Write-Back

对于 Write-Back 模式来说，更新操作发生的时候，数据写入缓存之后就立即返回了，而数据库的更新异步完成。这种模式在一些分布式系统中很常见。

这种方式带来的最大好处是拥有最大的请求吞吐量，并且操作非常迅速，数据库的更新甚至可以批量进行，因而拥有杰出的更新效率以及稳定的速率，这个缓存就像是一个写入的缓冲，可以平滑访问尖峰。另外，对于存在数据库短时间无法访问的问题，它也能够很好地处理。

但是它的弊端也很明显，异步更新一定会存在着不可避免的一致性问题，并且也存在着数据丢失的风险（数据写入缓存但还未入库时，如果宕机了，那么这些数据就丢失了）。





