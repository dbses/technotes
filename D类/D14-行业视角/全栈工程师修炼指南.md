# 导读 | 如何学习这个专栏？

# 学习路径 | 怎样成为一名优秀的全栈工程师？

**怎样修炼全栈技术？**

- 首先，我想说的是，**先成为合格的工程师，再谈全栈**。
- 其次，**在获取知识的基础上思考，尤其是从比较中思考**。
- 最后，**请不要忽视实践的力量**。

**专栏内容是怎样设计的？**

专栏的主要目的是介绍原理、分享认识、探讨观点、串联知识，并引发思考，带给你进一步学习和实践的机会，而不是完全一步一步教导具体怎么做。

- **内容广度：我会选择每个核心领域的代表性技术来介绍。**
- **内容深度：我会把深度控制在合适的位置，让入门到进阶的工程师都有收获。**

专栏包含网络协议和 Web 接口，MVC 架构相关，前端技术，持久层技术和最佳实践等几大章，这些内容会覆盖到基于 Web 的全栈技术最核心的部分。最后还有一章是综合性、自恰性强的专题，比如网站的性能优化、分页技术等。

# 01 | 网络互联的昨天、今天和明天：HTTP 协议的演化

# 02 | 为HTTP穿上盔甲：HTTPS

# ==第三章 从后端到前端==

# 14 | 别有洞天：从后端到前端

今天我们将迈入第三大基于 Web 的全栈技能领域——前端。

**为什么要学习前端技术？**

首先，它可以帮助你开阔眼界，为你的思维模式带来新的选项，整个全栈技术都有这样的特点，但是前端技术在这方面尤其明显。前端技术的结构和软件其它领域有着显著的不同，技术发展极其迅速，技术之水深不见底，开源社区百花齐放。

其次，它可以帮助你形成快速原型、即时验证和独立展示演示的优势，在迅捷的反馈中设计和编程。

再次，它可以帮助你建立产品思维。有人认为它能用来解决用户的核心问题，但实际上往往不是，解决核心问题主要还是靠后端的代码，但是前端的代码却是和用户最贴近和交互的部分，一个优秀的前端工程师总是具备非常强烈的产品属性。

最后，前端技术是全栈工程的必备技能。

**思维模式的转变**

如果你具备后端开发的经验，刚刚开始从后端转向前端，你可能会发现，有很多想当然的理解，不再适用，有很多想当然的解决方法，也不再有效。

1. 应用事件驱动编程

来看这样一段 JavaScript 代码：

```javascript
console.log("1");
 
setTimeout(function timeout() {
    console.log("2");
}, 0);
 
setTimeout(function timeout() {
    console.log("3");
}, 5000);
 
console.log("4");
```

你觉得打印结果应该是什么？是 1 -> 2 -> 4 -> 3 吗？在 Chrome 中，我们得到的结果如下：

```
1
4
undefined
2
3
```

这是为什么，上面的 undefined 又是什么？

为了回答上面的问题，我们需要了解 JavaScript 执行机制中的 Event Loop（事件循环）来理解上面的代码。

浏览器中 JavaScript 代码的执行通常是单线程的（对于 [Web Worker](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers) 这样的“例外”我们暂不讨论）——一个线程，一个调用栈，一次只做一件事。

具体说来，在整个 JavaScript 的世界里，引起代码运行的行为是通过事件驱动的，并且**全部是通过这唯一的一个勤奋的工作线程来执行的。那么当有事件产生的时候，这个工作线程不一定空闲，这就需要一个机制来让新产生的事件排队“等一等”**，等当前的工作完成之后，再来处理它。这个机制就是 Event Loop，这个等一等的事件，就被放在一个被称为事件（回调）队列的数据结构中。

于是上面的代码，实际在运行的时候，从事件队列的角度看，是这样的：

![image-20240113230928355](https://technotes.oss-cn-shenzhen.aliyuncs.com/2023/202401132309475.png)

工作线程不断地从整个事件队列的右侧取得新的事件来处理执行，而新的事件只会从左侧放入。主代码最先被执行，从上往下顺序执行，因此顺序是：

- 先打印 1；
- 在遇到第一个 setTimeout 的时候，告知浏览器，请在 0 秒之后往事件队列内放入执行打印 2 的事件；
- 在遇到第二个 setTimeout 的时候，告知浏览器，请在 5 秒之后往事件队列内放入执行打印 3 的事件；
- 再打印 4；
- 主代码执行完毕，Chrome 的控制台打印这段代码的返回值，但因为它没有返回值，于是就打印 undefined。

浏览器老老实实地按照要求放入了打印 2 的事件，虽然是第 0 秒就放入，但是因为放入的时候主代码还在执行，因此只能等待，它等到主代码执行完毕后才得到执行，打印了 2。

5 秒钟后，浏览器按照要求往队列里放入了打印 3 的事件，于是 3 被打印出来。

通过这种方式，JavaScript 可以让不同的任务在一个线程中完成，而整个任务编排的机制，**从代码的角度看，所有的逻辑都是通过七七八八的“异步回调”来完成的；而从程序员思维方式的角度看，以往基于线程的编程，变成了事件驱动的编程**。

另外，需要说明的是，浏览器的 JavaScript 执行是单线程的，但不代表浏览器是单线程的。浏览器通常还包含其它线程，比如说：

- 界面（GUI）渲染线程，这个线程的执行和上述的 JavaScript 工作线程是互斥的，即二者不可同时执行；
- 事件触发线程，这个也很好理解，我们介绍过有一个神秘人物帮着往队列中放入事件（例子中的回调打印 2 和回调打印 3），这个神秘人物就是事件触发线程。

2. 学写声明式代码
3. 培养交互思维

# 15 | 重剑无锋，大巧不工：JavaScript面向对象

首先，我们将通过面向对象的三大特征，结合实例，介绍 JavaScript 面向对象的知识：封装、继承以及多态。

**1. 封装**

在面向对象编程中，封装（Encapsulation）说的是一种通过接口抽象将具体实现包装并隐藏起来的方法。具体来说，封装的机制包括两大部分：

- 限制对对象内部组件直接访问的机制；
- 将数据和方法绑定起来，对外提供方法，从而改变对象状态的机制。

```javascript
function Book(name) {
    this.getName = () => {
        return name;
    };
    this.setName = (newName) => {
        name = newName;
    };
}
let book = new Book("Life");
book.setName("Time");
console.log(book.getName()); // Time
console.log(book.name); // 无法访问私有属性 name 的值
```

**2. 继承**

在面向对象编程中，继承（Inheritance）指的是一个对象或者类能够自动保持另一个对象或者类的实现的一种机制。我们经常讲的子类具备父类的所有特性，只是继承中的一种，叫做类继承；其实还有另一种，对象继承，这种继承只需要对象，不需要类。

在 ES6 以前，没有继承（extends）关键字，JavaScript 最常见的继承方式叫做**原型链继承**。原型（prototype）是 JavaScript 函数的一个内置属性，指向另外的一个对象，而那个对象的所有属性和方法，都会被这个函数的所有实例自动继承。

```javascript
function Base(name) {
    this.name = name;
}
function Child(name) {
    this.name = name;
}
Child.prototype = new Base();
 
var c = new Child("Life");
console.log(c.name); // "Life"
console.log(c instanceof Base); // true
console.log(c instanceof Child); // true
```

**3. 多态**

在面向对象编程中，多态（Polymorphism）指的是同样的接口，有着不同的实现。在 JavaScript 中没有用来表示接口的关键字，但是通过在不同实现类中定义同名的方法，我们可以轻易做到多态的效果，即同名方法在不同的类中有不同的实现。而由于没有类型和参数的强约束，它的灵活性远大于 Java 等静态语言。























