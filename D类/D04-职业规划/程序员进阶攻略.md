# 开篇词

![](https://technotes.oss-cn-shenzhen.aliyuncs.com/2023/202306182249839.png)

这是一条成长线的表意图，有两个部分：图上左侧的路径，是匹配不同成长阶段，对应不同职业角色；右侧是一条由不同成长阶段组成的成长线。

# <mark>征途启程之初</mark>

# 01 | 初心：为什么成为一名程序员？

回首往昔，我似乎是阴差阳错地走上了这条路，正因初心未明，所以早期的路上就多了很多迟疑和曲折。

![image-20230618231040069](https://technotes.oss-cn-shenzhen.aliyuncs.com/2023/202306182310105.png)

# 02 | 初惑：技术方向的选择

![image-20230618233656729](https://technotes.oss-cn-shenzhen.aliyuncs.com/2023/202306182336763.png)

如果你想预测一门语言还会存在多久，就看看它已经存在了多久。<mark>存活时间足够长的语言，可以预期，它未来也还可能存活这么长时间。</mark>当然这一论断并不绝对，但它更多想说明越是新的语言或技术，升级换代越快，也越容易被取代。

越年轻的语言和方向，风险越高。一个今年刚出现的新方向、新语言，你怎么知道它能在明年幸存下来？所以，考虑确定性的回报和更低的风险，你应该选择有一定历史的方向或语言，也许不能带来超额的回报，但最起码能带来稳定的回报，让你先在这个行业里立稳脚跟。在此基础上，再去关注新潮流、新方向或新技术，观察它们的可持续性。

**选择行业**

先想想自己想从事哪个行业的软件开发；然后，再看看：这个行业的现状如何？行业的平均增速如何？和其他行业相比如何？这个行业里最好的公司相比行业平均增速又如何？最后，再看看这些最好的公司都用些什么样的技术栈和语言。如果你想进入这样的公司，那就很简单了，就选择学这样的技术和语言。

# 03 | 初程：带上一份技能地图

**一、掌握**

1、开发平台

开发平台决定了你会成为什么类型和方向的程序员。比如：服务端、客户端或前端开发等。

2、常用算法

算法，表达的是一个计算的动态过程，它引入了一个度量标准：时空复杂度。

3、数据结构

数据结构通常都和算法一起出现，但算法表达的是动态特性，而数据结构表达的是一种静态的结构特性。我们需要熟悉并掌握的，包括：

- 数组 Array
- 链表 Linked List
- 队列 Queues
- 堆栈 Stacks
- 散列 Hashes
- 集合 Sets

**二、了解**

1、数据存储

- SQL 关系型数据库（如：MySQL、Oracle）
- NoSQL 非关系型数据库（如：HBase、MongoDB）
- Cache 缓存（如：Redis、Memcached）

2、测试方法

开发与测试这两种相反视角的切入维度，能真正长期地提高你写代码的效率和水平。

3、工程规范

最基础的工程规范是代码规范，包括两个方面：代码结构和代码风格。

4、开发流程

为了和团队其他成员更好地协作，每个新加入团队的成员都需要了解团队演进形成的开发流程规范。

5、源码管理

Git 诞生的背景是为 Linux 这样超大规模的开源项目准备的，自然决定了其能应对各种复杂场景的源码管理需求。所以，你至少要了解 Git，并用好它。

最后，我把以上内容总结为如下一张图：红色区域相对更小而聚焦，是需要掌握的部分，要求深度；蓝色区域的部分更广而泛，需要广度。

![image-20230619231441824](https://technotes.oss-cn-shenzhen.aliyuncs.com/2023/202306192314923.png)

# 04 | 初感：别了校园，入了江湖

**野蛮生长**

知乎上有个问题：“普通人到底跟职业运动员有多大差距？”里面有个回答，以篮球运动为例给出一个生动的评分体系。假如巅峰时的迈克尔·乔丹算满分 100，那么国内顶级的球员，巅峰时的易建联可能刚刚及格得分在 60～70 之间，而大部分业余选手基本就在 0.1～0.N 之间波动了。

幸运的是程序员这个职业不像运动员那么惨烈，借用上面的评分标准，假如把奠定计算机行业基础的那一批图灵奖得主级别的程序员定义在 90～100 分档，那么我们很多靠编码为生的程序员基本都在 1～10 分档间分布，而业余的只是写写 Demo 的程序员可能就是在 0.1～0.N 之间了。

所以，进入职场后，你需要先把得分从小数提高到整数，再持续努努力提升到两位数，搞不好就成了行业某个垂直细分领域小有名气的专家了。

都不需要及格的分数，程序员就能获得不错的成就感和回报。只需要是巅峰者的十分之一或二十分之一，基本就能超越身边绝大多数人了。望着遥远的巅峰不停地去靠近，翻越身前脚下的一座座小山包，然后不知不觉就超越了自己。

总之，应像野草一样野蛮而快速地生长起来。

**青春有价**

你持续学习，努力工作，年年涨薪 20%（注意我说的是年年，这很不容易，也许你会说跳一次槽就可能翻倍，但你能年年跳槽翻倍么），十年后你年的收入将是十年前的 6.2 倍，离十倍还有距离，但换算为年薪也有七八十万了。所以要想靠加薪加到月入十万真的是一件极难的事情，而且即使做到了也离我们心中的无价青春，还差很远吧？

认清了这个现实，我们明白了这十年的青春是十分有价的。所以这时有人说了，要去创业，才有可能突破。前两年（2015）都在鼓励万众创业，但真实的现实是，你要给目前的万众创业者一个稳定的七八十万年薪，80%+ 的创业者表示就会放弃创业了，这数据是来自 TOMsInsight 深度观察文《互联网乱世之下，那些人才流动中的心酸和无奈》对 100 个创业者的抽样调查。

![image-20230620231004898](https://technotes.oss-cn-shenzhen.aliyuncs.com/2023/202306202310940.png)

那么持续努力的学习还有意义吗？我只是说你很难做到每年加薪 20%，但是却可以做到每年比去年的自己多增长 20% 的知识、见识和能力。而关于知识、见识和能力的积累与相应价值的变现，理论与现实的对比可能如下图，纵坐标：年薪（单位万），横坐标：工作年限。

![年薪与工作年限概念图](https://technotes.oss-cn-shenzhen.aliyuncs.com/2023/202306202304757.png)

现实不太可能因为你的能力每增长 20% 就会立刻体现在你的收入上。现实有两种可能：一种存在一个拐点让你的积累获得相应的价格体现，另一种也可能不存在这个拐点，停留在某个水平位。其中拐点就是我们现实中常说的机遇吧。

无论怎样，要想获得拐点出现的机遇，可能你也只能持续努力地积累下去。

# <mark>修炼：程序之术</mark>

# 05 | 架构与实现：它们的连接与分界？

把一种想法、一个需求变成代码，这叫 “实现”，而在此之前，技术上有一个过程称为设计，设计中有个特别的阶段叫 “架构”。

**架构与实现具体做什么**

从定义上，你已知道架构是一种结构设计，但它同时可能存在于不同的维度和层次上：

- 高维度：指系统、子系统或服务之间的切分与交互结构。
- 中维度：指系统、服务内部模块的切分与交互结构。
- 低维度：指模块组成的代码结构、数据结构、库表结构等。

而对于实现，最终交付物是程序代码，但这个过程中会发生什么？一般会有下面 6 个方面的考虑：选型评估；程序设计；执行效率；稳定健壮；维护运维；集成部署。

![image-20230621221758405](https://technotes.oss-cn-shenzhen.aliyuncs.com/2023/202306212217452.png)

以上，就是我针对整个实现过程自己总结的一个思维框架。如果你每次写代码时，都能有一个完善的思维框架，应该就能写出更好的代码。这个思维框架是在过去多年的编程经验中逐步形成的，在过去每次写代码时如果漏掉了其中某个部分，后来都以某种线上 Bug 或问题的形式，让我付出了代价，做出了偿还。

**架构与实现的关注点**

架构的一个核心关注点，如果只能是一个点，我想有一个很适合的字可以表达： 熵。“熵”是一个物理学术语，在热力学中表达系统的混乱程度。

这里我用一个图展示软件系统“熵”值的生命周期变化，如下：

![image-20230621222231194](https://technotes.oss-cn-shenzhen.aliyuncs.com/2023/202306212222235.png)

系统只要是活跃的，“熵”值就会在生命周期中不断波动。需求的增加和改变，就是在不断增加“熵”值（系统的混乱程度）。但软件系统的“熵”有个临界值，当达到并超过临界值后，软件系统的生命也基本到头了。这时，你可能将迫不得已采取一种行动：重写或对系统做架构升级。

如果你不关注、也不管理系统的“熵”值，它最终的发展趋势就如图中的蓝线，一直升高，达到临界点，届时你就不得不付出巨大的代价来进行系统架构升级。

关于实现的核心关注点，我们也可以用一个字表达：简。

简，是简单、简洁、简明、简化，都是在做减法，但不是简陋。关于实现的全部智慧都浓缩在了这一个字里，它不仅减少代码量，也减少了开发时间，减少了测试时间，减少了潜在 Bug 的数量，甚至减少了未来的维护、理解与沟通成本。

# 06 | 模式与框架：它们的关系与误区？

无

# 07 | 多维与视图：系统设计的思考维度与展现视图

在多年的工程实践中，我逐渐得到了一些维度的视图，下面就以我近些年一直在持续维护、设计、演进的系统（京东咚咚）为例来简单说明下。

**一、组成视图**

组成视图，表达了系统由哪些子系统、服务、组件部分构成。如下图示例，它对服务进行大类划分，图中用了不同的颜色来表达这种分类：

![image-20230704232205672](https://technotes.oss-cn-shenzhen.aliyuncs.com/2023/202307042322765.png)

**二、交互视图**

交互视图，表达了系统或服务与外部系统或服务的协作关系，也即：依赖与被依赖。

如下图，是一张宏观大倍率的整体交互视图示例。它隐藏了内部众多服务的交互细节，强调了终端和服务端，以及服务端内部交互的主要过程。这里依然以地图作类比，它体现了整体系统主干道场景的运动过程。而每一个服务本身，在整体的交互图中，都会有其位置，有些在主干道上，而有些则在支线上。

![image-20230704232224080](https://technotes.oss-cn-shenzhen.aliyuncs.com/2023/202307042322121.png)

**三、部署视图**

部署视图，表达系统的部署结构与环境。

部署视图，从不同的人员角色出发，关注点其实不一样，不过从应用开发和架构的角度来看，会更关注应用服务实际部署的主机环境、网络结构和其他一些环境元素依赖。下面是一张强调服务部署的机房结构、网络和依赖元素的部署图示例。

![image-20230704232237679](https://technotes.oss-cn-shenzhen.aliyuncs.com/2023/202307042322726.png)

**四、流程视图**

流程视图，表达系统内部实现的功能和控制逻辑流程。

下图是咚咚消息投递的一个功能逻辑流程表达，看起来就像是 UML 的序列图，但并没有完全遵循 UML 的图例语法（主要是我习惯的画图工具不支持）。而且，我想更多人即使是程序员也并不一定会清楚地了解和记得住 UML 的各种图例语法，所以都用文字做了补充说明，也就没必要一定要遵循其语法了，重点还是在于要把逻辑表达清楚。

![image-20230704232253357](https://technotes.oss-cn-shenzhen.aliyuncs.com/2023/202307042322414.png)

**五、状态视图**

状态视图，表达系统内部管理了哪些状态以及状态的变迁转移路径。

像咚咚这样的 IM 消息系统，就自带一个复杂的状态管理场景：消息的已读 / 未读状态。它的复杂性体现在，它本身就处在一个不可控的分布式场景下，在用户的多个终端和服务端之间，需要保持尽可能的最终一致性。

![image-20230704232316591](https://technotes.oss-cn-shenzhen.aliyuncs.com/2023/202307042323633.png)

# 08 | 代码与分类：工业级编程的代码分类与特征

各种系统代码，按代码的作用，大概都可以分为如下三类：

- 功能
- 控制
- 运维

如果你想提高编程水平，写出优雅的代码，那么就必须要清晰地认识清楚这三类代码。

**一、功能**

功能代码，是实现需求的业务逻辑代码，反映真实业务场景，包含大量领域知识。

一个程序软件系统，拥有完备的功能性代码仅是基本要求。因为业务逻辑的复杂度决定了功能性代码的复杂度，所以要把功能代码写好，最难的不是编码本身，而是搞清楚功能背后的需求并得到正确的理解。之后的编码活动，就仅是一个“翻译”工作了：把需求“翻译”为代码。

**二、控制**

控制代码，是控制业务功能逻辑代码执行的代码，即业务逻辑的执行策略。

编程领域熟悉的各类设计模式，都是在讲关于控制代码的逻辑。而如今，很多这些常用的设计模式基本都被各类开源框架固化了进去。比如，在 Java 中，Spring 框架提供的控制反转（IoC）、依赖注入（DI）就固化了工厂模式。

**三、运维**

运维代码，就是方便程序检测、诊断和运行时处理的代码。它们的存在，才让系统具备了真正工业级的可运维性。

最常见的检测诊断性代码，应该就是日志了，打日志太过简单，因此我们通常也就疏于考虑。其实即使是打日志也需要有意识的设计，评估到底应该输出多少日志，在什么位置输出日志，以及输出什么级别的日志。

# 09 | 粗放与精益：编程的两种思路与方式







# <mark>修炼：由术入道</mark>



# <mark>徘徊：道中彷徨</mark>



# <mark>寻路：路在何方</mark>



# <mark>蜕变：破茧成蝶</mark>



# <mark>结束语</mark>

