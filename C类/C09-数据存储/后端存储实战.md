# 开篇词 | 从今天起，换种方式学存储

不论是在传统 IT 行业，还是在互联网，我们都会接触很多的系统。不同的系统，它的业务不一样，有做社交的，有做电商的，还有做内容的。系统的规模也不一样，有很小规模的系统，也有巨无霸系统。

不同的系统会面临五花八门的问题，但总结下来我发现一个“神奇”的规律：

==凡是那些特别难解决的、让你付出巨大代价的，或者是损失惨重的技术问题，几乎都可以归为存储系统的问题。==

这个规律其实并不神奇，它是有原因的。

你可以想一下，我们开发的各种业务系统，几乎都是 MIS 系统，中文叫“管理信息系统”。管理信息系统这个词的含义就是字面的意思：管理信息的系统。这里面的信息是什么？其实就是数据。不管你的系统业务是什么样的，最终都要落到对信息的管理上，或者通俗点儿说，你系统的业务功能最终的结果就是数据。

只要这个数据是正确的，剩下的都是小问题。数据错了、丢了，甚至数据处理不及时，这些都是损失惨重的大问题。

所以用于承载数据的存储系统就显得非常重要，如果说，你能构建一个安全可靠、快速稳定的存储系统，基于这个基础之上构建的业务系统，显然就让人放心多了。

所以说，存储是系统中最核心、最重要、最关键的组成部分，没有之一。

**存储的特点**

我们常用的存储系统有很多，有单机的也有分布式的，有数据库、文件系统，还有一些介于二者之间的，种类非常多。无论是什么样的存储，比如 MySQL、Redis、ElasticSearch 等等，它们都有几个共同的特点。

第一个特点是难用。

拿 MySQL 举例，我要存取对象，必须把对象转换成 MySQL 表中的行，还得写 SQL 语句才能存取。是不是很难用？难用你还不得不用，并且还得把它给用好了，这里面有很多的方法、技巧和实践经验需要学习掌握。

第二个特点是慢。

一个经过良好优化过的业务系统，它的性能瓶颈一定是存储。从性能角度上来说，存储系统就是整个系统中最短的那块儿板子，存储系统有多慢，你的整个系统就多慢。如何优化存储性能，从而让整个系统运转如飞，这里面同样有很多的方法、技巧和经验需要掌握。

第三个特点是杂。

MySQL、Redis、ElasticSearch、HBase、Hive、MongoDB、RocksDB、CockroachDB 等等，这些存储还真就是谁都替代不了谁，每一种都有它擅长的地方，有它适用的场景，当然也有很突出的短板。如何根据业务系统的特点，选择合适的存储来构建我们的系统，这也是需要学习和掌握的。

**如何学习存储？**

我认为是实战，从问题入手。每一节课，我们一起解决一两个实战的问题，比如：为什么明明数据量和访问量不大，MySQL 还是很慢？数据库宕机了怎么办？

我们的课程设计就是按照系统的发展过程，分成了创业篇、高速增长篇和海量数据篇这三个部分。

在创业篇，我们重点解决从 0 到 1 的问题；比如：如何低成本高质量地快速构建一个小规模的订单存储系统。

在高速增长篇，我们关注在高速变化的过程中，你的系统一定会遇到的一些共通问题，以及该如何应对这些问题。比如说，如何从单机的存储系统逐步演进为分布式存储系统；如何在线平滑的扩容我们的存储系统。

在海量数据篇，我们重点解决高并发、海量数据情况下的存储系统该如何设计的问题。比如，海量的埋点数据该怎么存储；如何在各种数据库之前实时迁移和同步海量数据，等等。

# 课前加餐 | 电商系统是如何设计的？

本节课，我们一起以一个创业公司的 CTO 的视角，设计一个最小化的电商系统，在这个过程中帮你理清楚电商系统的架构。

我们的故事从一个电话开始。某一天，一个曾经认识但并不太熟悉的老板突然来了一个电话：“我有一个改变世界的想法，就差一个程序员了！你来吧！”

新公司很快就成立了，你成了新公司的 CTO。关于要如何改变世界，目前唯一能确定的是，老板要做一个电商系统。具体做成什么样，还不清楚。你需要和老板讨论需求。

在需求还不太明确的情况下，比较可行的方式就是，先把那些不太会变化的核心系统搭建出来，尽量简单地实现出一个最小化的系统，然后再逐步迭代完善。

**电商系统的核心流程是什么样的？**

遵照软件工程的一般规律，我们先从需求阶段开始。理想情况下，应该由系统分析师或者是产品经理来承担这个任务。

怎么来做需求分析？这里面我们不讲那些做需求分析的方法和理论，只告诉你最重要、最关键的一个点。那就是==不要一上来就设计功能，而是先要回答下面这两个问题：==

1. 这个系统（或者是功能）是给哪些人用的？
2. 这些人使用这个系统来解决什么问题？

这两个问题的答案，我把它们称为业务需求。

第一个问题，电商系统给哪些人用？首先得有买东西的人，我们叫“用户”，还得有卖东西的人？我们叫“运营人员”。还有老板。

第二个问题：用户、运营和老板，分别用电商系统来干什么？用户用系统来买东西，运营用系统来卖东西，老板需要在系统中看到他赚了多少钱。

业务需求，稍加细化后，可以用下面这个图来清晰的表述：

![image-20240924231833442](https://technotes.oss-cn-shenzhen.aliyuncs.com/2024/202409242318495.png)

这个图在 UML（统一建模语言）中称为用例图（Use Case），是需求分析的时候你需要画的第一张图。

然后我们来分析电商系统的流程。显然，一个电商系统最主要的业务流程，一定是购物这个流程。你应该很容易就能把这个流程分析出来，它的流程图是这样的：

![image-20240924225651402](https://technotes.oss-cn-shenzhen.aliyuncs.com/2024/202409242256913.png)

所有的电商几乎都是这样一个流程，我和你一起来看一下这个流程。

- 流程从用户选购商品开始，用户先从你的 App 中浏览商品；
- 找到心仪的商品之后，把商品添加到购物车里面；
- 都选好了之后，打开购物车，下一个订单；
- 下单结算之后，就可以支付了；
- 支付成功后，运营人员接下来会给每个已经支付的订单发货；
- 邮寄商品给用户之后，用户确认收货，到这里一个完整的购物流程就结束了。

**如何根据流程来划分功能模块？**

接下来，我们把这个业务流程再细化，看一下电商系统如何来实现这个流程？我把细化之后的流程，绘制成了下面这个时序图（Sequence Diagram）：

![image-20240924225736515](https://technotes.oss-cn-shenzhen.aliyuncs.com/2024/202409242257564.png)

我们一起看下这个时序图中的每个步骤。

1. 用户开始浏览商品，需要有一个商品模块来支撑，给用户展示商品的介绍、价格等等这些信息。
2. 用户把选好的商品加入购物车，这个步骤，也需要一个购物车模块来维护用户购物车中的商品。
3. 用户下单肯定需要一个订单模块来创建这个新订单。订单创建好了之后，需要把订单中的商品从购物车中删除掉。
4. 订单创建完成后，需要引导用户付款，也就是发起支付流程，这里需要有一个支付模块来实现支付功能，用户成功完成支付之后，需要把订单的状态变更为“已支付”。
5. 之后运营人员就可以发货了，在系统中，发货这个步骤，需要扣减对应商品的库存数量，这个功能需要库存模块来实现，发货完成后，还需要把订单状态变更为“已发货”。
6. 最后，用户收货之后，在系统中确认收货，系统把订单状态变更为“已收货”，流程结束。

这个流程涉及到的功能模块有：商品、购物车、订单、支付和库存，这几个模块就是一个电商系统中的核心功能模块。

除了购物流程中涉及到的：商品、订单、购物车、支付、库存五个模块以外，还有促销、用户、账户、搜索推荐和报表这几个模块，这些都是构建一个电商系统必不可少的功能。

电商系统的功能模块划分如下：

![image-20240924225951473](https://technotes.oss-cn-shenzhen.aliyuncs.com/2024/202409242259525.png)

我们一个一个来说每个模块需要实现的功能。

- 商品：维护和展示商品信息和价格。
- 订单：维护订单信息和订单状态，计算订单金额。
- 购物车：维护用户购物车中的商品。
- 支付：负责与系统内外部的支付渠道对接，实现支付功能。
- 库存：维护商品的库存数量和库存信息。
- 促销：制定促销规则，计算促销优惠。
- 用户：维护系统的用户信息，注意用户模块它是一个业务模块，一般不负责用户登录和认证，这是两个完全不同的功能。
- 账户：负责维护用户的账户余额。
- 搜索推荐：负责商城中，搜索商品和各种列表页和促销页的组织和展示，简单的说就是决定让用户优先看到哪些商品。
- 报表：实现统计和分析功能，生成报表，给老板来做经营分析和决策使用。

至此，我们就完成了一个电商系统的概要设计。

**小结**

作为一个开发者，你在做需求分析的时候，需要把握的一个要点：不要一上来就设计功能，而是要先理清业务需求：

- 这个系统是给哪些人用的？
- 他们分别用这个系统来解决什么问题？

这样可以确保你做出来的系统，大体上不会偏离用户的预期。

# ==创业篇==

# 01 | 创建和更新订单时，如何保证数据准确无误？

一个合格的订单系统，最基本的要求是什么？数据不能错。

**订单系统的核心功能和数据**

订单系统必备的功能，它包含但远远不限于：

1. 创建订单；
2. 随着购物流程更新订单状态；
3. 查询订单，包括用订单数据生成各种报表。

为了支撑这些必备功能，在数据库中，我们至少需要有这样几张表：

1. 订单主表：也叫订单表，保存订单的基本信息。
2. 订单商品表：保存订单中的商品信息。
3. 订单支付表：保存订单的支付和退款信息。
4. 订单优惠表：保存订单使用的所有优惠信息。

这几个表之间的关系是这样的：订单主表和后面的几个子表都是一对多的关系，关联的外键
就是订单主表的主键，也就是订单号。

绝大部分订单系统它的核心功能和数据结构都是这样的。

**如何避免重复下单？**

解决办法是，让你的订单服务具备幂等性。我们可以利用数据库的这种“主键唯一约束”特性，在插入数据的时候带上主键，来解决创建订单服务的幂等性问题。

具体的做法是这样的，我们给订单系统增加一个“生成订单号”的服务，这个服务没有参数，返回值就是一个新的、全局唯一的订单号。在用户进入创建订单的页面时，前端页面先调用这个生成订单号服务得到一个订单号，在用户提交订单的时候，在创建订单的请求中带着这个订单号。

![image-20240925232245194](https://technotes.oss-cn-shenzhen.aliyuncs.com/2024/202409252322595.png)

**如何解决 ABA 问题？**

在并发环境下，你需要注意 ABA 问题。什么是 ABA 问题呢？我举个例子你就明白了。比如说，订单支付之后，小二要发货，发货完成后要填个快递单号。假设说，小二填了一个单号 666，刚填完，发现填错了，赶紧再修改成 888。对订单服务来说，这就是 2 个更新订单的请求。

但是 666 更新成功的响应丢了，调用方没收到成功响应，自动重试，再次发起 666 请求，单号又被更新成 666 了，这数据显然就错了。这就是非常有名的 ABA 问题。

具体的时序你可以参考下面这张时序图：

![image-20240925232538701](https://technotes.oss-cn-shenzhen.aliyuncs.com/2024/202409252325768.png)

ABA 问题怎么解决？这里给你提供一个比较通用的解决方法。给你的订单主表增加一列，列名可以叫 version。具体的 SQL 可以这样来写：

```sql
UPDATE orders set tracking_number = 666, version = version + 1
WHERE version = 8;
```

在这条 SQL 的 WHERE 条件中，version 的值需要页面在更新的时候通过请求传进来。

# 02 | 流量大、数据多的商品详情页系统该如何设计？

电商的商品系统主要功能就是增删改查商品信息，没有很复杂的业务逻辑。不过，设计这个系统的存储，你仍然需要着重考虑两个方面的问题。

第一，要考虑高并发的问题。不管是什么电商系统，商详页一定是整个系统中 DAU（日均访问次数）最高的页面之一。如果说，在设计存储的时候，没有考虑到高并发的问题，大促的时候，支撑商详页的商品系统必然是第一个被流量冲垮的系统。

第二，要考虑的是商品数据规模的问题。商详页的数据规模，我总结了六个字：数量多，重量大。

为什么数量多，国内一线的电商，SKU（直译为：库存单元，在电商行业，你可以直接理解为“商品”）的数量大约在几亿到几十亿这个量级。

再说这个“重量大”，你可以打开一个电商商详页看一下，从上一直拉到底，你看看有多长？十屏以内的商详页那都叫短的，并且这里面不光有大量的文字，还有大量的图片和视频，甚至还有 AR/VR 的玩法在里面，所以说，每个商详页都是个“大胖子”。

支持商品系统的存储，要保存这么多的“大胖子”，还要支撑高并发，任务艰巨。

**商品系统需要保存哪些数据？**

我把一个商详页里面的所有信息总结了一下，放在下面这张思维导图里面。

![image-20240925234328692](https://technotes.oss-cn-shenzhen.aliyuncs.com/2024/202409252343764.png)

这里面，右边灰色的部分，来自于电商的其他系统，我们暂且不去管这些，左边彩色部分，都是商品系统需要存储的内容。

应该选择哪种存储系统来保存这么复杂的商品数据呢？任何一种存储都是没办法满足的，解决的思路是分而治之，我们可以把商品系统需要存储的数据按照特点，分成商品基本信息、商品参数、图片视频和商品介绍几个部分来分别存储。

**商品数据如何存储？**

==第一，商品基本信息该如何存储？==

我们先来分析商品的基本信息，它包括商品的主副标题、价格、颜色等一些商品最基本、主要的属性。这些属性都是固定的，不太可能会因为需求或者不同的商品而变化，而且，这部分数据也不会太大。所以，还是建议你在数据库中建一张表来保存商品的基本信息。

然后，还需要在数据库前面，加一个缓存，帮助数据抵挡绝大部分的读请求。

==第二，使用 MongoDB 保存商品参数==

我们再来分析商品参数，参数就是商品的特征。比如说，电脑的内存大小、手机的屏幕尺寸、酒的度数、口红的色号等等。和商品的基本属性一样，都是结构化的数据。但麻烦的是，不同类型的商品，它的参数是完全不一样的。

大多数数据库，都要求数据表要有一个固定的结构。但有一种数据库，没有这个要求。特别适合保存像“商品参数”这种，属性不固定的数据，这个数据库就是 MongoDB。

对于商品参数信息，数据量大、数据结构不统一，这些 MongoDB 都可以很好的满足。我们也不需要事务和多表联查，MongoDB 简直就是为了保存商品参数量身定制的一样。

==第三，使用对象存储保存图片和视频==

图片和视频由于占用存储空间比较大，一般的存储方式都是，在数据库中只保存图片视频的 ID 或者 URL，实际的图片视频以文件的方式单独存储。

现在图片和视频存储技术已经非常成熟了，首选的方式就是保存在对象存储（Object Storage）中。各大云厂商都提供对象存储服务，比如国内的七牛云、AWS 的 S3 等等，也有开源的对象存储产品，比如 MinIO，可以私有化部署。

==第四，将商品介绍静态化==

商品介绍在商详页中占得比重是最大的，包含了大量的带格式文字、图片和视频。其中图片和视频自然要存放在对象存储里面，商品介绍的文本，一般都是随着商详页一起静态化，保存在 HTML 文件中。

什么是静态化呢？静态化是相对于动态页面来说的。一般我们部署到 Tomcat 中的 Web 系统，返回的都是动态页面，也就是在 Web 请求时，动态生成的。比如说商详页，一个 Web 请求过来，带着 SKUID，Tomcat 中的商详页模块，再去访问各种数据库、调用后端服务，动态把这个商详页拼出来，返回给浏览器。

不过，现在基本上没有系统会这么干了，你想，对于每个 SKU 的商详页，你每次动态生成的页面内容不是完全一样的么？生成这么多次，不仅浪费服务器资源，速度还慢，关键问题是，Tomcat 能能抗的并发量和 Nginx 完全不是一个数量级的。

商详页的绝大部分内容都是商品介绍，它是不怎么变的。那不如就把这个页面事先生成好，保存成一个静态的 HTML，访问商详页的时候，直接返回这个 HTML。这就是静态化。

商详页静态化之后，不仅仅是可以节省服务器资源，还可以利用 CDN 加速，把商详页放到离用户最近的 CDN 服务器上，让商详页访问更快。

**小结**

我把商品系统的存储绘制成下面这张图：

![image-20240810102603160](https://technotes.oss-cn-shenzhen.aliyuncs.com/2024/202408101026240.png)

图中实线表示每访问一次商详页，需要真正传输的数据，虚线表示当商详页数据发生变化的时候才需要进行一次数据传输。

# 03 | 复杂而又重要的购物车系统，应该如何设计？

今天这节课我们来说一下购物车系统的存储该如何设计。

购物车系统的功能，主要的就三个：把商品加入购物车（后文称“加购”）、购物车列表页、发起结算下单，再加上一个在所有界面都要显示的购物车小图标。

那对应的存储模型应该怎么设计？很简单，只要一个“购物车”实体就够了。它的主要属性有：SKUID（商品 ID）、数量、加购时间和勾选状态。

![image-20240926232012656](https://technotes.oss-cn-shenzhen.aliyuncs.com/2024/202409262320775.png)

购物车的功能虽然很简单，但是在设计购物车系统的存储时，仍然有一些特殊的问题需要考虑。

**设计购物车存储时需要考虑的问题**

比如下面这几个问题：

1. 用户没登录，在浏览器中加购，关闭浏览器再打开，刚才加购的商品还在不在？
2. 用户没登录，在浏览器中加购，然后登录，刚才加购的商品还在不在？
3. 退出登录后，上一步加购的商品在不在？
4. 再打开手机，用相同的用户登录，第二步加购的商品还在不在呢？

我们先简单解释一下这四个问题：

1. 如果用户没登录，加购的商品也会被保存在用户的电脑里，这样即使关闭浏览器再打开，购物车的商品仍然存在。
2. 如果用户先加购，再登录，登录前加购的商品就会被自动合并到用户名下，所以登录后购物车中仍然有登录前加购的商品。
3. 退出登录后，这时又变为未登录状态，但是之前未登录时加购的商品已经被合并到刚刚登录的用户名下了，所以购物车是空的。
4. 使用手机登录相同的用户，看到的就是该用户的购物车，这时无论你在手机 App、电脑还是微信中登录，只要是相同的用户，看到是同一个购物车，所以第二步加购的商品是存在的。

要解决上面这些问题，其实只要在存储设计时，把握这几个原则就可以了：

1. 如果未登录，需要临时暂存购物车的商品；
1. 用户登录时，把暂存购物车的商品合并到用户购物车中，并且清除暂存购物车；
3. 用户登录后，购物车中的商品，需要在浏览器、手机 APP 和微信等等这些终端中都保持同步。

所以，购物车系统需要保存两类购物车，一类是未登录情况下的“暂存购物车”，一类是登录后的“用户购物车”。

**如何设计“暂存购物车”的存储？**

我们先来看下暂存购物车的存储该怎么实现。暂存购物车应该存在客户端还是存在服务端？

如果保存在服务端，那每个暂存购物车都需要有一个全局唯一的标识，这个标识并不太容易设计。所以，肯定是保存在客户端好，因为每个客户端就保存它自己唯一一个购物车就可以了，不需要标识。

客户端的存储可以选择的不太多：Session、Cookie 和 LocalStorage。存在哪儿最合适？SESSION 是不太合适的，原因是，SESSION 的保留时间短，而且 SESSION 的数据实际上还是保存在服务端的。剩余的两种存储，Cookie 和 LocalStorage 都可以用来保存购物车数据，选择哪种方式更好呢？各有优劣。

- 使用 Cookie 存储，实现起来比较简单，加减购物车、合并购物车的过程中，由于服务端可以读写 Cookie，这样全部逻辑都可以在服务端实现，并且客户端和服务端请求的次数也相对少一些。
- 使用 LocalStorage 存储，实现相对就复杂一点儿，客户端和服务端都要实现一些业务逻辑，但 LocalStorage 的好处是，它的存储容量比 Cookie 的 4KB 上限要大得多，而且不用像 Cookie 那样，无论用不用，每次请求都要带着，可以节省带宽。

所以，如果你设计的是个小型电商，那用 Cookie 存储实现起来更简单。再比如，你的电商是面那种批发的行业用户，用户需要加购大量的商品，那 Cookie 可能容量不够用，选择 LocalStorage 就更合适。

不管选择哪种存储，暂存购物车保存的数据格式都是一样的，我们可以直接用 JSON 表示：

```json
{
    "cart": [
        {
            "SKUID": 8888,
            "timestamp": 1578721136,
            "count": 1,
            "selected": true
        },
        {
            "SKUID": 6666,
            "timestamp": 1578721138,
            "count": 2,
            "selected": false
        }
    ]
}
```

**如何设计“用户购物车”的存储？**

因为用户购物车必须要保证多端的数据同步，所以数据必须保存在服务端。常规的思路是，设计一张购物车表，把数据存在 MySQL 中。这个表的结构同样可以参照刚刚讲的实体模型来设计：

![image-20240810210133817](https://technotes.oss-cn-shenzhen.aliyuncs.com/2024/202408102101863.png)

你也可以选择更快的 Redis 来保存购物车数据，以用户 ID 作为 Key，用一个 Redis 的 HASH 作为 Value 来保存购物车中的商品。比如：

```json
{
    "KEY": "USERID_123",
    "VALUE": [
        {
            "FIELD": "PRODUCT_001",
            "FIELD_VALUE": {
                "timestamp": 1578721136,
                "count": 1,
                "selected": true
            }
        },
        {
            "FIELD": "PRODUCT_002",
            "FIELD_VALUE": {
                "timestamp": 1578721138,
                "count": 2,
                "selected": false
            }
        }
    ]
}
```

其中 KEY 中的值是一个用户 ID，FIELD 里存放的是商品 ID，FIELD_VALUE 是一个 JSON 字符串，保存加购时间、商品数量和勾选状态。

# 04 | 事务：账户余额总是对不上账，怎么办？

账户系统负责记录和管理用户账户的余额，这个余额就是每个用户临时存在电商的钱，来源可能是用户充值或者退货退款等多种途径。

从业务需求角度来分析，一个最小化的账户系统，它的数据模型可以用下面这张表来表示：

![image-20240927225851292](https://technotes.oss-cn-shenzhen.aliyuncs.com/2024/202409272258395.png)

这个表包括用户 ID、账户余额和更新时间三个字段。每次交易的时候，根据用户 ID 去更新这个账户的余额就可以了。

**为什么总是对不上账？**

每个账户系统都不是孤立存在的，至少要和财务、订单、交易这些系统有着密切的关联。理想情况下，账户系统内的数据应该是自洽的。所有用户的账户余额加起来，应该等于这个电商公司在银行专用账户的总余额。账户系统的数据也应该和其他系统的数据能对的上。比如说，每个用户的余额应该能和交易系统中充值记录，以及订单系统中的订单对的上。

不过，由于业务和系统的复杂性，现实情况却是，很少有账户系统能够做到一点不差的对上每一笔账。

对不上账的原因非常多，比如业务变化、人为修改了数据、系统之间数据交换失败等等。那作为系统的设计者，我们只关注“如何避免由于技术原因导致的对不上账”就可以了，有哪些是因为技术原因导致的呢？比如说：网络请求错误，服务器宕机、系统 Bug 等。

**记录账户的流水**

如果说只是满足功能需求，账户系统只记录余额，每次交易的时候更新账户余额就够了。但是这样做有一个问题，如果账户余额被篡改，是没有办法追查的，所以在记录余额的同时，还需要记录每一笔交易记录，也就是账户的流水。流水的数据模型至少需要包含：流水 ID、交易金额、交易时间戳以及交易双方的系统、账户、交易单号等信息。

在设计账户流水时，有几个重要的原则必须遵守，最好是用技术手段加以限制。

1. 流水记录只能新增，一旦记录成功不允许修改和删除。即使是由于正当原因需要取消一笔已经完成的交易，也不应该去删除交易流水。正确的做法是再记录一笔“取消交易”的流水。
2. 流水号必须是递增的，我们需要用流水号来确定交易的先后顺序。

在对账的时候，一旦出现了流水和余额不一致，并且无法通过业务手段来确定到底是哪儿记错了的情况，一般的处理原则是以交易流水为准来修正余额数据，这样才能保证后续的交易能“对上账”。

流水表结构参考如下：

```sql
CREATE TABLE `account_log` (
  `log_id` int NOT NULL AUTO_INCREMENT COMMENT '流水号',
  `amount` int NOT NULL COMMENT '交易金额',
  `timestamp` datetime NOT NULL COMMENT '时间戳',
  `from_system` int NOT NULL COMMENT '转出系统编码',
  `from_system_transaction_number` int DEFAULT NULL COMMENT '转出系统的交易号',
  `from_account` int DEFAULT NULL COMMENT '转出账户',
  `to_system` int NOT NULL COMMENT '转入系统编码',
  `to_system_transaction_number` int DEFAULT NULL COMMENT '转入系统的交易号',
  `to_account` int DEFAULT NULL COMMENT '转入账户',
  `transaction_type` int NOT NULL COMMENT '交易类型编码',
  PRIMARY KEY (`log_id`)
);
```

那从技术上，如何保证账户系统中流水和余额数据一致呢？

**使用事务来保证账户和流水的数据一致性**

在设计对外提供的服务接口时，不能提供单独更新余额或者流水的功能，只提供交易功能。我们需要在实现交易功能的时候，同时记录流水并修改余额，并且要尽可能保证，在任何情况下，记录流水和修改余额这两个操作，要么都成功，要么都失败。不能有任何一笔交易出现，记录了流水但余额没更新，或者更新了余额但是没记录流水。

数据库提供了事务机制来解决这个问题。我们先看一下如何来使用 MySQL 的事务，实现一笔交易。

```sql
mysql> begin; -- 开始事务
Query OK, 0 rows affected (0.00 sec)

-- 流水号888,交易金额100
mysql> insert into account_log ...;
Query OK, 1 rows affected (0.01 sec)

-- 更新账户余额,账户余额200
mysql> update account_balance ...;
Query OK, 1 rows affected (0.00 sec)

mysql> commit; -- 提交事务
Query OK, 0 rows affected (0.01 sec)
```

我们来看一下，事务可以给我们提供什么样的保证？

首先，它可以保证，记录流水和更新余额这两个操作，要么都成功，要么都失败。不会出现，只更新了一个表而另一个表没更新的情况。这是事务的原子性（Atomic）。

事务还可以保证，数据库中的数据总是从一个一致性状态（888 流水不存在，余额是 100元）转换到另外一个一致性状态（888 流水存在，余额是 200 元）。对于其他事务来说，不存在任何中间状态（888 流水存在，但余额是 100 元）。这是事务的一致性 (Consistency)。

数据库为了实现一致性，必须保证每个事务的执行过程中，中间状态对其他事务是不可见的。比如说我们在事务 A 中，写入了 888 这条流水，但是还没有提交事务，那在其他事务中，都不应该读到 888 这条流水记录。这是事务的隔离性 (Isolation)。

最后，只要事务提交成功，数据一定会被持久化到磁盘中，后续即使发生数据库宕机，也不会改变事务的结果。这是事务的持久性 (Durability)。

**理解事务的隔离级别**

如果要完全满足 ACID，一个数据库的所有事务和 SQL 都只能串行执行，这个性能肯定是不能满足一般系统的要求的。

对账户系统和其他大多数交易系统来说，事务的原子性和持久性是必须要保证的，否则就失去了使用事务的意义，而一致性和隔离性其实可以做适当牺牲，来换取性能。所以，MySQL 提供了四种隔离级别，具体来看一下这个表：

![image-20240927231744348](https://technotes.oss-cn-shenzhen.aliyuncs.com/2024/202409272317439.png)

先说两种不常用的，第一种 RU 级别，实际上就是完全不隔离。每个进行中事务的中间状态，对其他事务都是可见的，所以有可能会出现“脏读”。这种级别虽然性能好，但是存在脏读的可能，对应用程序来说比较难处理，所以基本不用。

第四种“序列化”级别，具备完美的“隔离性”和“一致性”，性能最差，也很少会用到。

常用的隔离级别其实就是 RC 和 RR 两种，其中 MySQL 默认的隔离级别是 RR。

我来简单说一下“幻读”。在实际业务中，很少能遇到幻读，即使遇到，也基本不会影响到数据准确性，所以你简单了解一下即可。在 RR 隔离级别下，我们开启一个事务，之后直到这个事务结束，在这个事务内其他事务对数据的更新是不可见的。

比如我们在会话 A 中开启一个事务，准备插入一条 ID 为 1000 的流水记录。查询一下当前流水，不存在 ID 为 1000 的记录，可以安全地插入数据。

```sql
mysql> -- 会话 A
mysql> begin;
Query OK, 0 rows affected (0.00 sec)

mysql> select log_id from account_log where log_id = 1000;
Empty set (0.00 sec)
```

这时候，另外一个会话抢先插入了这条 ID 为 1000 的流水记录。

```sql
mysql> -- 会话 B
mysql> begin;
Query OK, 0 rows affected (0.00 sec)

mysql> insert into account_log values
    -> (1000, 100, NOW(), 1, 1001, NULL, 0, NULL, 0, 0);
Query OK, 1 row affected (0.00 sec)

mysql> commit;
Query OK, 0 rows affected (0.00 sec)
```

然后会话 A 再执行相同的插入语句时，就会报主键冲突错误，但是由于事务的隔离性，它执行查询的时候，却查不到这条 ID 为 1000 的流水，就像出现了“幻觉”一样，这就是幻读。

```sql
mysql> -- 会话 A
mysql> insert into account_log values
    -> (1000, 100, NOW(), 1, 1001, NULL, 0, NULL, 0, 0);
ERROR 1062 (23000): Duplicate entry '1000' for key 'account_log.PRIMARY'

mysql> select log_id from account_log where log_id = 1000;
Empty set (0.00 sec)
```

那如何解决上面说到的幻读问题呢？可以使用乐观锁的思想：

1. 我们给账户余额表增加一个 log_id 属性，记录最后一笔交易的流水号。
2. 首先开启事务，查询并记录当前账户的余额和最后一笔交易的流水号。
3. 然后写入流水记录。
4. 再更新账户余额，需要在更新语句的 WHERE 条件中限定，只有流水号等于之前查询出的流水号时才更新。
5. 然后检查更新余额的返回值，如果更新成功就提交事务，否则回滚事务。

账户表结构参考如下：

```sql
CREATE TABLE `account_balance` (
  `user_id` int NOT NULL COMMENT '用户ID',
  `balance` int NOT NULL COMMENT '余额',
  `timestamp` datetime NOT NULL COMMENT '时间戳',
  `log_id` int NOT NULL COMMENT '最后一笔交易的流水号',
  PRIMARY KEY (`user_id`)
);
```

这个实现在隔离级别为 RC 和 RR 时，都是安全的。需要特别注意的一点是，更新账户余额后，不能只检查更新语句是不是执行成功了，还需要检查返回值中变更的行数是不是等于 1。因为即使流水号不相等，余额没有更新，这条更新语句的执行结果仍然是成功的，只是更新了 0 条记录。

# 05 | 分布式事务：如何保证多个系统间的数据是一致的？

如果一笔交易，涉及到跨多个系统、多个数据库的时候，用单一的数据库事务就没办法解决了。

现在的技术趋势是云原生和微服务，每个微服务独立部署并且拥有自己的数据库。跨越微服务和数据库的交易就成为一种越来越普遍的情况。我们的业务系统微服务化之后，不可避免地要面对跨系统的数据一致性问题。

如何来解决这种跨系统、跨数据库的数据一致性问题呢？

**什么是分布式事务？**

我们知道即使是数据库事务，它考虑到性能的因素，大部分情况下不能也不需要百分之百地实现 ACID，所以才有了事务四种隔离级别。

理论上，分布式事务也是事务，也需要遵从 ACID 四个特性，但实际情况是，在分布式系统中，因为必须兼顾性能和高可用，所以是不可能完全满足 ACID 的。我们常用的几种分布式事务的实现方法，都是“残血版”的事务，而且相比数据库事务，更加的“残血”。

分布式事务的解决方案有很多，比如：2PC、3PC、TCC、Saga 和本地消息表等等。这些方法，它的强项和弱项都不一样，适用的场景也不一样。其中，2PC 和本地消息表这两种分布式事务的解决方案，比较贴近于我们日常开发的业务系统。

**2PC：订单与优惠券的数据一致性问题**

2PC 也叫二阶段提交，是一种常用的分布式事务实现方法。我们用订单和优惠券的例子来说明一下。在我们购物下单时，如果使用了优惠券，订单系统和优惠券系统都要更新自己的数据，才能完成“在订单中使用优惠券”这个操作。

2PC 引入了一个事务协调者的角色，来协调订单系统和促销系统。

所谓的二阶段指的是准备阶段和提交阶段。在准备阶段，协调者分别给订单系统和促销系统发送“准备”命令，订单和促销系统收到准备命令之后，开始执行准备操作。准备阶段都需要做哪些事儿呢？你可以理解为，除了提交数据库事务以外的所有工作，都要在准备阶段完成。

“准备”工作完成后，订单系统和优惠券系统给事务协调者返回“准备成功”。协调者在收到两个系统“准备成功”的响应之后，开始进入第二阶段。

等两个系统都准备好了之后，进入提交阶段。提交阶段就比较简单了，协调者再给这两个系统发送“提交”命令，每个系统提交自己的数据库事务，然后给协调者返回“提交成功”响应，协调者收到所有响应之后，给客户端返回成功响应，整个分布式事务就结束了。

![image-20240811223154176](https://technotes.oss-cn-shenzhen.aliyuncs.com/2024/202408112235128.png)

这是正常情况，接下来才是重点：异常情况下怎么办？

我们还是分两个阶段来说明。在准备阶段，如果任何一步出现错误或者是超时，协调者就会给两个系统发送“回滚事务”请求。每个系统在收到请求之后，回滚自己的数据库事务。以下是异常情况的时序图：

![image-20240811223346708](https://technotes.oss-cn-shenzhen.aliyuncs.com/2024/202408112235823.png)

如果准备阶段成功，进入提交阶段，这个时候整个分布式事务只能成功，不能失败。如果发生网络传输失败的情况，需要反复重试，直到提交成功为止。

如果这个阶段发生宕机，包括两个数据库宕机或者订单服务、促销服务所在的节点宕机，还是有可能出现订单库完成了提交，但促销库因为宕机自动回滚，导致数据不一致的情况。但是，因为提交的过程非常简单，执行很快，出现这种情况的概率非常小，所以，从实用的角度来说，2PC 这种分布式事务的方法，实际的数据一致性还是非常好的。

在实现 2PC 的时候，没必要单独启动一个事务协调服务，这个协调服务的工作最好和订单服务或者优惠券服务放在同一个进程里面，这样做有两个好处：

- 参与分布式事务的进程更少，故障点也就更少，稳定性更好；
- 减少了一些远程调用，性能也更好一些；

2PC 是一种强一致的设计，它可以保证原子性和隔离性。只要 2PC 事务完成，订单库和促销库中的数据一定是一致的状态，即要么都成功，要么都失败。所以 2PC 比较适合那些对数据一致性要求比较高的场景，比如我们这个订单优惠券的场景，如果一致性保证不好，有可能会被黑客利用，一张优惠券反复使用，那样我们的损失就大了。

2PC 也有很明显的缺陷，整个事务的执行过程需要阻塞服务端的线程和数据库的会话，所以，2PC 在并发场景下的性能不会很高。并且，一旦过程中协调者宕机，就会导致订单库或者促销库的事务会话一直卡在等待提交阶段，直到事务超时自动回滚。

卡住的这段时间内，数据库有可能会锁住一些数据，服务中会卡住一个数据库连接和线程，这些都会造成系统性能严重下降，甚至整个服务被卡住。

==所以，只有在需要强一致、并且并发量不大的场景下，才考虑使用 2PC。==

**本地消息表：订单与购物车的数据一致性问题**

2PC 它的适用场景其实是很窄的，更多的情况下，只要保证数据最终一致就可以了。比如说，在购物流程中，用户在购物车界面选好商品后，点击“去结算”按钮进入订单页面创建一个新订单。这个过程我们的系统其实做了两件事儿。

- 第一，订单系统需要创建一个新订单，订单关联的商品就是购物车中选择的那些商品。
- 第二，创建订单成功后，购物车系统需要把订单中的这些商品从购物车里删掉。

这也是一个分布式事务问题，创建订单和清空购物车这两个数据更新操作需要保证，要么都成功，要么都失败。但是，清空购物车这个操作，它对一致性要求就没有扣减优惠券那么高，订单创建成功后，晚几秒钟再清空购物车，完全是可以接受的。只要保证经过一个小的延迟时间后，最终订单数据和购物车数据保持一致就可以了。

本地消息表非常适合解决这种分布式最终一致性的问题。我们一起来看一下，如何使用本地消息表来解决订单与购物车的数据一致性问题。

本地消息表的实现思路是这样的，订单服务在收到下单请求后，正常使用订单库的事务去更新订单的数据，并且，在执行这个数据库事务过程中，在本地记录一条消息。这个消息就是一个日志，内容就是“清空购物车”这个操作。因为这个日志是记录在本地的，这里面没有分布式的问题，那这就是一个普通的单机事务，那我们就可以让订单库的事务，来保证记录本地消息和订单库的一致性。完成这一步之后，就可以给客户端返回成功响应了。

然后，我们再用一个异步的服务，去读取刚刚记录的清空购物车的本地消息，调用购物车系统的服务清空购物车。购物车清空之后，把本地消息的状态更新成已完成就可以了。异步清空购物车这个过程中，如果操作失败了，可以通过重试来解决。最终，可以保证订单系统和购物车系统它们的数据是一致的。

> 消息队列 RocketMQ 提供一种事务消息的功能，其实就是本地消息表思想的一个实现。使用事务消息可以达到和本地消息表一样的最终一致性，相比我们自己来实现本地消息表，使用起来更加简单，你也可以考虑使用。

如果看事务的 ACID 四个特性，本地消息表这种方法，它只能满足 D（持久性），A（原子性）C（一致性）、I（隔离性）都比较差，但是，它的优点非常突出。

- 首先，实现简单，在单机事务的基础上稍加改造就可以实现分布式事务
- 另外，本地消息表的性能非常好，和单机事务的性能几乎没有差别
- 在这个基础上，还提供了大部分情况下都能接受的“数据最终一致性”的保证

所以，本地消息表是更加实用的分布式事务实现方法。

# 06 | 如何用Elasticsearch构建商品搜索系统？

搜索这个特性可以说是无处不在，现在很多网站或者系统都提供搜索功能。

今天这节课，我们就以电商中的商品搜索作为例子，来讲一下，如何用 ES(Elasticsearch) 来快速、低成本地构建一个体验还不错的搜索系统。

我先来和你分析一下，为什么数据库不适合做搜索。

**为什么数据库不适合做搜索？**

搜索的核心需求是全文匹配，对于全文匹配，数据库的索引是根本派不上用场的，那只能全表扫描。全表扫描已经非常慢了，这还不算，还需要在每条记录上做全文匹配，也就是一个字一个字的比对，这个速度就更慢了。所以，使用数据来做搜索，性能上完全没法满足要求。

那 ES 是怎么来解决搜索问题的呢？

**理解倒排索引机制**

我们来举个例子说明一下，假设我们有这样两个商品，一个是烟台红富士苹果，一个是苹果手机 iPhone XS Max。

![image-20241009225500740](https://technotes.oss-cn-shenzhen.aliyuncs.com/2024/202410092255982.png)

> 这个表里面的 DOCID 就是唯一标识一条记录的 ID，和数据库里面的主键是类似的。

为了能够支持快速地全文搜索，ES 中对于文本采用了一种特殊的索引：倒排索引（Inverted Index）。那我们看一下在 ES 中，这两条商品数据倒排索引长什么样？请看下面这个表。

![image-20241009225625630](https://technotes.oss-cn-shenzhen.aliyuncs.com/2024/202410092256724.png)

可以看到，这个倒排索引的表，它是以单词作为索引的 Key，然后每个单词的倒排索引的值是一个列表，这个列表的元素就是含有这个单词的商品记录的 DOCID。

这个倒排索引怎么构建的呢？当我们往 ES 写入商品记录的时候，ES 会先对需要搜索的字段，也就是商品标题进行分词。分词就是把一段连续的文本按照语义拆分成多个单词。然后 ES 按照单词来给商品记录做索引，就形成了上面那个表一样的倒排索引。

当我们搜索关键字“苹果手机”的时候，ES 会对关键字也进行分词，比如说，“苹果手机”被分为“苹果”和“手机”。然后，ES 会在倒排索引中去搜索我们输入的每个关键字分词，搜索结果应该是：

![image-20241009225703187](https://technotes.oss-cn-shenzhen.aliyuncs.com/2024/202410092257284.png)

666 和 888 这两条记录都能匹配上搜索的关键词，但是 888 这个商品比 666 这个商品匹配度更高，因为它两个单词都能匹配上，所以按照匹配度把结果做一个排序，最终返回的搜索结果就是：

- **苹果**Apple iPhone XS Max (A2104) 256GB 金色 移动联通电信 4G**手机**双卡双待
- 烟台红富士**苹果**5kg 一级铂金大果 单果 230g 以上 新鲜水果

看起来搜索的效果还是不错的。

**为什么倒排索引可以做到快速搜索？**

我和你一起来分析一下上面这个例子的查找性能。

这个搜索过程，其实就是对上面的倒排索引做了二次查找，一次找“苹果”，一次找“手机”。注意，整个搜索过程中，我们没有做过任何文本的模糊匹配。ES 的存储引擎存储倒排索引时，肯定不是像我们上面表格中展示那样存成一个二维表，实际上它的物理存储结构和 MySQL 的 InnoDB 的索引是差不多的，都是一颗查找树。

对倒排索引做两次查找，也就是对树进行二次查找，它的时间复杂度，类似于 MySQL 中的二次命中索引的查找。显然，这个查找速度，比用 MySQL 全表扫描加上模糊匹配的方式，要快好几个数量级。

**如何在 ES 中构建商品的索引?**

理解了倒排索引的原理之后，我们一起用 ES 构建一个商品索引，简单实现一个商品搜索系统。虽然 ES 是为搜索而生的，但本质上，它仍然是一个存储系统。ES 里面的一些概念，基本上都可以在关系数据库中找到对应的名词，为了便于你快速理解这些概念，我把这些概念的对应关系列出来，你可以对照理解。

![image-20241009231435342](https://technotes.oss-cn-shenzhen.aliyuncs.com/2024/202410092314532.png)

为了能让 ES 支持中文分词，需要给 ES 安装一个中文的分词插件 IK Analysis for Elasticsearch，这个插件的作用就是告诉 ES 怎么对中文文本进行分词。

安装完成后，需要重启 ES，验证一下是否安装成功：

```shell
curl -X POST "localhost:9200/_analyze?pretty" -H 'Content-Type: application/json' -d '{ "analyzer": "ik_smart", "text": "极客时间" }'
{
  "tokens" : [
    {
      "token" : "极",
      "start_offset" : 0,
      "end_offset" : 1,
      "type" : "CN_CHAR",
      "position" : 0
    },
    {
      "token" : "客",
      "start_offset" : 1,
      "end_offset" : 2,
      "type" : "CN_CHAR",
      "position" : 1
    },
    {
      "token" : "时间",
      "start_offset" : 2,
      "end_offset" : 4,
      "type" : "CN_WORD",
      "position" : 2
    }
  ]
}
```

为了能实现商品搜索，我们需要先把商品信息存放到 ES 中，首先我们先定义存放在 ES 中商品的数据结构，也就是 MAPPING。

![image-20241009232026032](https://technotes.oss-cn-shenzhen.aliyuncs.com/2024/202410092320145.png)

当用户在搜索商品的时候，我们在 ES 中来匹配商品标题，返回符合条件商品的 sku_id 列表。ES 默认提供了标准的 RESTful 接口。

接下来我们使用上面这个 MAPPING 创建 INDEX，类似于 MySQL 中创建一个表。INDEX 的名称是 sku。

```shell
curl -X PUT "localhost:9200/sku" -H 'Content-Type: application/json' -d 
'{
    "mappings": {
        "properties": {
            "sku_id": {
                "type": "long"
            },
            "title": {
                "type": "text",
                "analyzer": "ik_max_word",
                "search_analyzer": "ik_max_word"
            }
        }
    }
}'
{"acknowledged":true,"shards_acknowledged":true,"index":"sku"}
```

由于我们要在 title 这个字段上进行全文搜索，所以我们把数据类型定义为 text，并指定使用我们刚刚安装的中文分词插件 IK 作为这个字段的分词器。

创建好 INDEX 之后，就可以往 INDEX 中写入商品数据，插入数据需要使用 HTTP POST 方法：

```shell
curl -X POST "localhost:9200/sku/_doc/" -H 'Content-Type: application/json' -d '{
    "sku_id": 100002860826,
    "title": "烟台红富士苹果 5kg 一级铂金大果 单果230g以上 新鲜水果"
}'
{
    "_index":"sku","_type":"_doc","_id":"yxQVSHABiy2kuAJG8ilW","_version":1,"result":"created",
    "_shards":{"total":2,"successful":1,"failed":0},
    "_seq_no":0,"_primary_term":1
}

curl -X POST "localhost:9200/sku/_doc/" -H 'Content-Type: application/json' -d '{
    "sku_id": 100000177760,
    "title": "苹果 Apple iPhone XS Max (A2104) 256GB 金色 移动联通电信4G手机 双卡双待"
}'
{
    "_index":"sku","_type":"_doc","_id":"zBQWSHABiy2kuAJGgim1","_version":1,"result":"created",
    "_shards":{"total":2,"successful":1,"failed":0},
    "_seq_no":0,"_primary_term":1
}
```

这里面我们插入了两条商品数据，一个烟台红富士，一个 iPhone 手机。然后就可以直接进行商品搜索了，搜索使用 HTTP GET 方法。

```shell
curl -X GET 'localhost:9200/sku/_search?pretty' -H 'Content-Type: application/json' -d '{
    "query" : { "match" : { "title" : "苹果手机" }}
}'
{
    "took" : 23,
    "timed_out" : false,
    "_shards" : {
        "total" : 1,
        "successful" : 1,
        "skipped" : 0,
        "failed" : 0
    },
    "hits" : {
        "total" : {
            "value" : 2,
            "relation" : "eq"
        },
        "max_score" : 0.8594865,
        "hits" : [
            {
                "_index" : "sku",
                "_type" : "_doc",
                "_id" : "zBQWSHABiy2kuAJGgim1",
                "_score" : 0.8594865,
                "_source" : {
                    "sku_id" : 100000177760,
                    "title" : "苹果 Apple iPhone XS Max (A2104) 256GB 金色 移动联通电信4G手机 双卡双待"
                }
            },
            {
                "_index" : "sku",
                "_type" : "_doc",
                "_id" : "yxQVSHABiy2kuAJG8ilW",
                "_score" : 0.18577608,
                "_source" : {
                    "sku_id" : 100002860826,
                    "title" : "烟台红富士苹果 5kg 一级铂金大果 单果230g以上 新鲜水果"
                }
            }
        ]
    }
}
```

我们先看一下请求中的 URL，其中的“sku”代表要在 sku 这个 INDEX 内进行查找，“_search”是一个关键字，表示要进行搜索，参数 pretty 表示格式化返回的 JSON，这样方便阅读。

再看一下请求 BODY 的 JSON，query 中的 match 表示要进行全文匹配，匹配的字段就是 title，关键字是“苹果手机”。

# ==高速增长篇==







# ==海量数据篇==





















