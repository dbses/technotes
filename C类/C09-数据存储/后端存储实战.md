# 开篇词 | 从今天起，换种方式学存储

不论是在传统 IT 行业，还是在互联网，我们都会接触很多的系统。不同的系统，它的业务不一样，有做社交的，有做电商的，还有做内容的。系统的规模也不一样，有很小规模的系统，也有巨无霸系统。

不同的系统会面临五花八门的问题，但总结下来我发现一个“神奇”的规律：

==凡是那些特别难解决的、让你付出巨大代价的，或者是损失惨重的技术问题，几乎都可以归为存储系统的问题。==

这个规律其实并不神奇，它是有原因的。

你可以想一下，我们开发的各种业务系统，几乎都是 MIS 系统，中文叫“管理信息系统”。管理信息系统这个词的含义就是字面的意思：管理信息的系统。这里面的信息是什么？其实就是数据。不管你的系统业务是什么样的，最终都要落到对信息的管理上，或者通俗点儿说，你系统的业务功能最终的结果就是数据。

只要这个数据是正确的，剩下的都是小问题。数据错了、丢了，甚至数据处理不及时，这些都是损失惨重的大问题。

所以用于承载数据的存储系统就显得非常重要，如果说，你能构建一个安全可靠、快速稳定的存储系统，基于这个基础之上构建的业务系统，显然就让人放心多了。

所以说，存储是系统中最核心、最重要、最关键的组成部分，没有之一。

**存储的特点**

我们常用的存储系统有很多，有单机的也有分布式的，有数据库、文件系统，还有一些介于二者之间的，种类非常多。无论是什么样的存储，比如 MySQL、Redis、ElasticSearch 等等，它们都有几个共同的特点。

第一个特点是难用。

拿 MySQL 举例，我要存取对象，必须把对象转换成 MySQL 表中的行，还得写 SQL 语句才能存取。是不是很难用？难用你还不得不用，并且还得把它给用好了，这里面有很多的方法、技巧和实践经验需要学习掌握。

第二个特点是慢。

一个经过良好优化过的业务系统，它的性能瓶颈一定是存储。从性能角度上来说，存储系统就是整个系统中最短的那块儿板子，存储系统有多慢，你的整个系统就多慢。如何优化存储性能，从而让整个系统运转如飞，这里面同样有很多的方法、技巧和经验需要掌握。

第三个特点是杂。

MySQL、Redis、ElasticSearch、HBase、Hive、MongoDB、RocksDB、CockroachDB 等等，这些存储还真就是谁都替代不了谁，每一种都有它擅长的地方，有它适用的场景，当然也有很突出的短板。如何根据业务系统的特点，选择合适的存储来构建我们的系统，这也是需要学习和掌握的。

**如何学习存储？**

我认为是实战，从问题入手。每一节课，我们一起解决一两个实战的问题，比如：为什么明明数据量和访问量不大，MySQL 还是很慢？数据库宕机了怎么办？

我们的课程设计就是按照系统的发展过程，分成了创业篇、高速增长篇和海量数据篇这三个部分。

在创业篇，我们重点解决从 0 到 1 的问题；比如：如何低成本高质量地快速构建一个小规模的订单存储系统。

在高速增长篇，我们关注在高速变化的过程中，你的系统一定会遇到的一些共通问题，以及该如何应对这些问题。比如说，如何从单机的存储系统逐步演进为分布式存储系统；如何在线平滑的扩容我们的存储系统。

在海量数据篇，我们重点解决高并发、海量数据情况下的存储系统该如何设计的问题。比如，海量的埋点数据该怎么存储；如何在各种数据库之前实时迁移和同步海量数据，等等。

# 课前加餐 | 电商系统是如何设计的？

本节课，我们一起以一个创业公司的 CTO 的视角，设计一个最小化的电商系统，在这个过程中帮你理清楚电商系统的架构。

我们的故事从一个电话开始。某一天，一个曾经认识但并不太熟悉的老板突然来了一个电话：“我有一个改变世界的想法，就差一个程序员了！你来吧！”

新公司很快就成立了，你成了新公司的 CTO。关于要如何改变世界，目前唯一能确定的是，老板要做一个电商系统。具体做成什么样，还不清楚。你需要和老板讨论需求。

在需求还不太明确的情况下，比较可行的方式就是，先把那些不太会变化的核心系统搭建出来，尽量简单地实现出一个最小化的系统，然后再逐步迭代完善。

**电商系统的核心流程是什么样的？**

遵照软件工程的一般规律，我们先从需求阶段开始。理想情况下，应该由系统分析师或者是产品经理来承担这个任务。

怎么来做需求分析？这里面我们不讲那些做需求分析的方法和理论，只告诉你最重要、最关键的一个点。那就是==不要一上来就设计功能，而是先要回答下面这两个问题：==

1. 这个系统（或者是功能）是给哪些人用的？
2. 这些人使用这个系统来解决什么问题？

这两个问题的答案，我把它们称为业务需求。

第一个问题，电商系统给哪些人用？首先得有买东西的人，我们叫“用户”，还得有卖东西的人？我们叫“运营人员”。还有老板。

第二个问题：用户、运营和老板，分别用电商系统来干什么？用户用系统来买东西，运营用系统来卖东西，老板需要在系统中看到他赚了多少钱。

业务需求，稍加细化后，可以用下面这个图来清晰的表述：

![image-20240924231833442](https://technotes.oss-cn-shenzhen.aliyuncs.com/2024/202409242318495.png)

这个图在 UML（统一建模语言）中称为用例图（Use Case），是需求分析的时候你需要画的第一张图。

然后我们来分析电商系统的流程。显然，一个电商系统最主要的业务流程，一定是购物这个流程。你应该很容易就能把这个流程分析出来，它的流程图是这样的：

![image-20240924225651402](https://technotes.oss-cn-shenzhen.aliyuncs.com/2024/202409242256913.png)

所有的电商几乎都是这样一个流程，我和你一起来看一下这个流程。

- 流程从用户选购商品开始，用户先从你的 App 中浏览商品；
- 找到心仪的商品之后，把商品添加到购物车里面；
- 都选好了之后，打开购物车，下一个订单；
- 下单结算之后，就可以支付了；
- 支付成功后，运营人员接下来会给每个已经支付的订单发货；
- 邮寄商品给用户之后，用户确认收货，到这里一个完整的购物流程就结束了。

**如何根据流程来划分功能模块？**

接下来，我们把这个业务流程再细化，看一下电商系统如何来实现这个流程？我把细化之后的流程，绘制成了下面这个时序图（Sequence Diagram）：

![image-20240924225736515](https://technotes.oss-cn-shenzhen.aliyuncs.com/2024/202409242257564.png)

我们一起看下这个时序图中的每个步骤。

1. 用户开始浏览商品，需要有一个商品模块来支撑，给用户展示商品的介绍、价格等等这些信息。
2. 用户把选好的商品加入购物车，这个步骤，也需要一个购物车模块来维护用户购物车中的商品。
3. 用户下单肯定需要一个订单模块来创建这个新订单。订单创建好了之后，需要把订单中的商品从购物车中删除掉。
4. 订单创建完成后，需要引导用户付款，也就是发起支付流程，这里需要有一个支付模块来实现支付功能，用户成功完成支付之后，需要把订单的状态变更为“已支付”。
5. 之后运营人员就可以发货了，在系统中，发货这个步骤，需要扣减对应商品的库存数量，这个功能需要库存模块来实现，发货完成后，还需要把订单状态变更为“已发货”。
6. 最后，用户收货之后，在系统中确认收货，系统把订单状态变更为“已收货”，流程结束。

这个流程涉及到的功能模块有：商品、购物车、订单、支付和库存，这几个模块就是一个电商系统中的核心功能模块。

除了购物流程中涉及到的：商品、订单、购物车、支付、库存五个模块以外，还有促销、用户、账户、搜索推荐和报表这几个模块，这些都是构建一个电商系统必不可少的功能。

电商系统的功能模块划分如下：

![image-20240924225951473](https://technotes.oss-cn-shenzhen.aliyuncs.com/2024/202409242259525.png)

我们一个一个来说每个模块需要实现的功能。

- 商品：维护和展示商品信息和价格。
- 订单：维护订单信息和订单状态，计算订单金额。
- 购物车：维护用户购物车中的商品。
- 支付：负责与系统内外部的支付渠道对接，实现支付功能。
- 库存：维护商品的库存数量和库存信息。
- 促销：制定促销规则，计算促销优惠。
- 用户：维护系统的用户信息，注意用户模块它是一个业务模块，一般不负责用户登录和认证，这是两个完全不同的功能。
- 账户：负责维护用户的账户余额。
- 搜索推荐：负责商城中，搜索商品和各种列表页和促销页的组织和展示，简单的说就是决定让用户优先看到哪些商品。
- 报表：实现统计和分析功能，生成报表，给老板来做经营分析和决策使用。

至此，我们就完成了一个电商系统的概要设计。

**小结**

作为一个开发者，你在做需求分析的时候，需要把握的一个要点：不要一上来就设计功能，而是要先理清业务需求：

- 这个系统是给哪些人用的？
- 他们分别用这个系统来解决什么问题？

这样可以确保你做出来的系统，大体上不会偏离用户的预期。

# ==创业篇==

# 01 | 创建和更新订单时，如何保证数据准确无误？





# 02 | 流量大、数据多的商品详情页系统该如何设计？

商品系统的存储：

![image-20240810102603160](https://technotes.oss-cn-shenzhen.aliyuncs.com/2024/202408101026240.png)



# 03 | 复杂而又重要的购物车系统，应该如何设计？

购物车系统的功能，主要的就三个：把商品加入购物车（后文称“加购”）、购物车列表页、发起结算下单，再加上一个在所有界面都要显示的购物车小图标。

1. 用户没登录，在浏览器中加购，关闭浏览器再打开，刚才加购的商品还在不在？
2. 用户没登录，在浏览器中加购，然后登录，刚才加购的商品还在不在？
3. 关闭浏览器再打开，上一步加购的商品在不在？
4. 再打开手机，用相同的用户登录，第二步加购的商品还在不在呢？

**如何设计“暂存购物车”的存储？**

购物车的数据格式：

```json
{
    "cart": [
        {
            "SKUID": 8888,
            "timestamp": 1578721136,
            "count": 1,
            "selected": true
        },
        {
            "SKUID": 6666,
            "timestamp": 1578721138,
            "count": 2,
            "selected": false
        }
    ]
}
```

**如何设计“用户购物车”的存储？**

![image-20240810210133817](https://technotes.oss-cn-shenzhen.aliyuncs.com/2024/202408102101863.png)

# 04 | 事务：账户余额总是对不上账，怎么办？

**为什么总是对不上账？**

对不上账的原因非常多，比如业务变化、人为修改了数据、系统之间数据交换失败等等。那作为系统的设计者，我们只关注“如何避免由于技术原因导致的对不上账”就可以了，有哪些是因为技术原因导致的呢？比如说：网络请求错误，服务器宕机、系统 Bug 等。

那从技术上，如何保证账户系统中流水和余额数据一致呢？

**使用数据库事务来保证数据一致性**

我们需要在实现交易功能的时候，同时记录流水并修改余额，并且要尽可能保证，在任何情况下，记录流水和修改余额这两个操作，要么都成功，要么都失败。

首先，它可以保证，记录流水和更新余额这两个操作，要么都成功，要么都失败。不会出现，只更新了一个表而另一个表没更新的情况。这是事务的原子性（Atomic）。

事务还可以保证，数据库中的数据总是从一个一致性状态（888 流水不存在，余额是 100元）转换到另外一个一致性状态（888 流水存在，余额是 200 元）。对于其他事务来说，不存在任何中间状态（888 流水存在，但余额是 100 元）。这是事务的一致性 (Consistency)。

数据库为了实现一致性，必须保证每个事务的执行过程中，中间状态对其他事务是不可见的。比如说我们在事务 A 中，写入了 888 这条流水，但是还没有提交事务，那在其他事务中，都不应该读到 888 这条流水记录。这是事务的隔离性 (Isolation)。

最后，只要事务提交成功，数据一定会被持久化到磁盘中，后续即使发生数据库宕机，也不会改变事务的结果。这是事务的持久性 (Durability)。

**理解事务的隔离级别**

我来简单说一下“幻读”。在实际业务中，很少能遇到幻读，即使遇到，也基本不会影响到数据准确性，所以你简单了解一下即可。

在 RR 隔离级别下，我们开启一个事务，之后直到这个事务结束，在这个事务内其他事务对数据的更新是不可见的。

比如我们在会话 A 中开启一个事务，准备插入一条 ID 为 1000 的流水记录。查询一下当前流水，不存在 ID 为 1000 的记录，可以安全地插入数据。

```sql
mysql> -- 会话 A
mysql> select log_id from account_log where log_id = 1000;
Empty set (0.00 sec)
```

这时候，另外一个会话抢先插入了这条 ID 为 1000 的流水记录。

```sql
mysql> -- 会话 B
mysql> begin;
Query OK, 0 rows affected (0.00 sec)

mysql> insert into account_log values
    -> (1000, 100, NOW(), 1, 1001, NULL, 0, NULL, 0, 0);
Query OK, 1 row affected (0.00 sec)

mysql> commit;
Query OK, 0 rows affected (0.00 sec)
```

然后会话 A 再执行相同的插入语句时，就会报主键冲突错误，但是由于事务的隔离性，它执行查询的时候，却查不到这条 ID 为 1000 的流水，就像出现了“幻觉”一样，这就是幻读。

```sql
mysql> -- 会话 A
mysql> insert into account_log values
    -> (1000, 100, NOW(), 1, 1001, NULL, 0, NULL, 0, 0);
ERROR 1062 (23000): Duplicate entry '1000' for key 'account_log.PRIMARY'

mysql> select log_id from account_log where log_id = 1000;
Empty set (0.00 sec)
```

# 05 | 分布式事务：如何保证多个系统间的数据是一致的？

**到底什么是分布式事务？**

要解决分布式一致性问题，你必须掌握几种分布式事务的实现原理。

我们知道即使是数据库事务，它考虑到性能的因素，大部分情况下不能也不需要百分之百地实现 ACID，所以才有了事务四种隔离级别。

理论上，分布式事务也是事务，也需要遵从 ACID 四个特性，但实际情况是，在分布式系统中，因为必须兼顾性能和高可用，所以是不可能完全满足 ACID 的。我们常用的几种分布式事务的实现方法，都是“残血版”的事务，而且相比数据库事务，更加的“残血”。

分布式事务的解决方案有很多，比如：2PC、3PC、TCC、Saga 和本地消息表等等。这些方法，它的强项和弱项都不一样，适用的场景也不一样。其中，2PC 和本地消息表这两种分布式事务的解决方案，比较贴近于我们日常开发的业务系统。

**2PC：订单与优惠券的数据一致性问题**

2PC 也叫二阶段提交，是一种常用的分布式事务实现方法。我们用订单和优惠券的例子来说明一下。在我们购物下单时，如果使用了优惠券，订单系统和优惠券系统都要更新自己的数据，才能完成“在订单中使用优惠券”这个操作。

所谓的二阶段指的是准备阶段和提交阶段。在准备阶段，协调者分别给订单系统和促销系统发送“准备”命令，订单和促销系统收到准备命令之后，开始执行准备操作。准备阶段都需要做哪些事儿呢？你可以理解为，除了提交数据库事务以外的所有工作，都要在准备阶段完成。

“准备”工作完成后，订单系统和优惠券系统给事务协调者返回“准备成功”。协调者在收到两个系统“准备成功”的响应之后，开始进入第二阶段。

等两个系统都准备好了之后，进入提交阶段。提交阶段就比较简单了，协调者再给这两个系统发送“提交”命令，每个系统提交自己的数据库事务，然后给协调者返回“提交成功”响应，协调者收到所有响应之后，给客户端返回成功响应，整个分布式事务就结束了。

![image-20240811223154176](https://technotes.oss-cn-shenzhen.aliyuncs.com/2024/202408112235128.png)

这是正常情况，接下来才是重点：异常情况下怎么办？

我们还是分两个阶段来说明。在准备阶段，如果任何一步出现错误或者是超时，协调者就会给两个系统发送“回滚事务”请求。每个系统在收到请求之后，回滚自己的数据库事务。以下是异常情况的时序图：

![image-20240811223346708](https://technotes.oss-cn-shenzhen.aliyuncs.com/2024/202408112235823.png)

如果准备阶段成功，进入提交阶段，这个时候整个分布式事务只能成功，不能失败。

如果发生网络传输失败的情况，需要反复重试，直到提交成功为止。

如果这个阶段发生宕机，包括两个数据库宕机或者订单服务、促销服务所在的节点宕机，还是有可能出现订单库完成了提交，但促销库因为宕机自动回滚，导致数据不一致的情况。但是，因为提交的过程非常简单，执行很快，出现这种情况的概率非常小，所以，从实用的角度来说，2PC 这种分布式事务的方法，实际的数据一致性还是非常好的。

在实现 2PC 的时候，没必要单独启动一个事务协调服务，这个协调服务的工作最好和订单服务或者优惠券服务放在同一个进程里面，这样做有两个好处：

- 参与分布式事务的进程更少，故障点也就更少，稳定性更好；
- 减少了一些远程调用，性能也更好一些；

2PC 也有很明显的缺陷，即性能不会很高。

整个事务的执行过程需要阻塞服务端的线程和数据库的会话，并且，协调者是一个单点，一旦过程中协调者宕机，就会导致订单库或者促销库的事务会话一直卡在等待提交阶段，直到事务超时自动回滚。

==所以，只有在需要强一致、并且并发量不大的场景下，才考虑使用 2PC。==

**本地消息表：订单与购物车的数据一致性问题**

==2PC 它的适用场景其实是很窄的，更多的情况下，只要保证数据最终一致就可以了。==

比如说，在购物流程中，用户在购物车界面选好商品后，点击“去结算”按钮进入订单页面创建一个新订单。这个过程我们的系统其实做了两件事儿。

- 第一，订单系统需要创建一个新订单，订单关联的商品就是购物车中选择的那些商品。
- 第二，创建订单成功后，购物车系统需要把订单中的这些商品从购物车里删掉。

这也是一个分布式事务问题，创建订单和清空购物车这两个数据更新操作需要保证，要么都成功，要么都失败。但是，清空购物车这个操作，它对一致性要求就没有扣减优惠券那么高，订单创建成功后，晚几秒钟再清空购物车，完全是可以接受的。只要保证经过一个小的延迟时间后，最终订单数据和购物车数据保持一致就可以了。

本地消息表非常适合解决这种分布式最终一致性的问题。我们一起来看一下，如何使用本地消息表来解决订单与购物车的数据一致性问题。

本地消息表的实现思路是这样的，订单服务在收到下单请求后，正常使用订单库的事务去更新订单的数据，并且，在执行这个数据库事务过程中，在本地记录一条消息。这个消息就是一个日志，内容就是“清空购物车”这个操作。因为这个日志是记录在本地的，这里面没有分布式的问题，那这就是一个普通的单机事务，那我们就可以让订单库的事务，来保证记录本地消息和订单库的一致性。完成这一步之后，就可以给客户端返回成功响应了。

然后，我们再用一个异步的服务，去读取刚刚记录的清空购物车的本地消息，调用购物车系统的服务清空购物车。购物车清空之后，把本地消息的状态更新成已完成就可以了。异步清空购物车这个过程中，如果操作失败了，可以通过重试来解决。最终，可以保证订单系统和购物车系统它们的数据是一致的。

> 消息队列 RocketMQ 提供一种事务消息的功能，其实就是本地消息表思想的一个实现。使用事务消息可以达到和本地消息表一样的最终一致性，相比我们自己来实现本地消息表，使用起来更加简单，你也可以考虑使用。







# ==高速增长篇==







# ==海量数据篇==





















