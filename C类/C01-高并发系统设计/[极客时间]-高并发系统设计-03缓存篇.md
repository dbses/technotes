# 目录

![](高并发系统设计-03缓存篇.png)

------

缓存篇 (12-16)

# 12 | 缓存：数据库成为瓶颈后，动态数据的查询要如何加速？

我将从缓存定义、缓存分类和缓存优势劣势三个方面全方位带你掌握缓存的设计思想和理念，再用剩下 4 节课的时间，带你针对性地掌握使用缓存的正确姿势，以便让你在实际工作中能够更好地使用缓存提升整体系统的性能。

**什么是缓存**

做一次内存寻址大概需要 100ns，而做一次磁盘的查找则需要 10ms。

**缓存案例**

-  **HTTP 协议缓存机制**

**缓存与缓冲区**

缓冲区则是一块临时存储数据的区域，这些数据后面会被传输到其他设备上。

**缓存分类**

在我们日常开发中，常见的缓存主要就是**静态缓存、分布式缓存和热点本地缓存**这三种。

**缓存的不足**

缓存会给整体系统带来复杂度，并且会有数据不一致的风险。

缓存通常使用内存作为存储介质，但是内存并不是无限的。

缓存会给运维也带来一定的成本。

# 13 | 缓存的使用姿势（一）：如何选择缓存的读写策略？

缓存的读写策略是什么样的？如何做到缓存的高可用以及如何应对缓存穿透？

**Cache Aside（旁路缓存）策略**

- 问题：缓存和数据库数据不一致

  <img src="https://gitee.com/yanglu_u/ImgRepository/raw/master/images/20201120093535.jpg" style="zoom: 50%;" />

  因为变更数据库和变更缓存是两个独立的操作，而我们并没有对操作做任何的并发控制。那么当两个线程并发更新它们的时候，就会因为写入顺序的不同造成数据的不一致。

- 解决方案：Cache Aside 策略（旁路缓存策略）

  <img src="https://gitee.com/yanglu_u/ImgRepository/raw/master/images/20201120093540.jpg" style="zoom: 67%;" />

  先删除缓存再写库行不行？

  不行，同样会造成数据不一致，如下图：

  <img src="https://gitee.com/yanglu_u/ImgRepository/raw/master/images/20201120093545.jpg" style="zoom: 67%;" />

- 方案的不足

  <img src="https://gitee.com/yanglu_u/ImgRepository/raw/master/images/20201120093557.jpg" style="zoom: 67%;" />

  Cache Aside 存在的最大的问题是当写入比较频繁时，缓存中的数据会被频繁地清理，这样会对缓存的命中率有一些影响。

**Read/Write Through（读穿 / 写穿）策略**

这个策略的核心原则是用户只与缓存打交道，由缓存和数据库通信，写入或者读取数据。

Write Through 的策略是这样的：先查询要写入的数据在缓存中是否已经存在，如果已经存在，则更新缓存中的数据，并且由缓存组件同步更新到数据库中，如果缓存中数据不存在，我们把这种情况叫做“Write Miss（写失效）”。（发生写失效，1. 写入缓存，缓存组件更新数据库；2. 不写缓存，直接更新数据库）

Read Through 策略就简单一些，它的步骤是这样的：先查询缓存中数据是否存在，如果存在则直接返回，如果不存在，则由缓存组件负责从数据库中同步加载数据。

# 14 | 缓存的使用姿势（二）：缓存如何做到高可用？

前面几节课，我带你了解了缓存的原理、分类以及常用缓存的使用技巧。我们开始用缓存承担大部分的读压力，从而缓解数据库的查询压力，在提升性能的同时保证系统的稳定性。这时，你的电商系统整体的架构演变成下图的样子：

<img src="https://gitee.com/yanglu_u/ImgRepository/raw/master/images/20201120093602.jpg" style="zoom: 67%;" />

我们在 Web 层和数据库层之间增加了缓存层，请求会首先查询缓存，只有当缓存中没有需要的数据时才会查询数据库。

在这里，你需要关注缓存命中率这个指标（缓存命中率 = 命中缓存的请求数 / 总请求数）。一般来说，在你的电商系统中，核心缓存的命中率需要维持在 99% 甚至是 99.9%，哪怕下降 1%，系统都会遭受毁灭性的打击。

这绝不是危言耸听，我们来计算一下。假设系统的 QPS 是 10000/s，每次调用会访问 10 次缓存或者数据库中的数据，那么当缓存命中率仅仅减少 1%，数据库每秒就会增加 10000 * 10 * 1% = 1000 次请求。而一般来说我们单个 MySQL 节点的读请求量峰值就在 1500/s 左右，增加的这 1000 次请求很可能会给数据库造成极大的冲击。

我们要如何来解决这个问题，提升缓存的可用性呢？

我们可以通过部署多个节点，同时设计一些方案让这些节点互为备份。这样，当某个节点故障时，它的备份节点可以顶替它继续提供服务。**而这些方案就是我们本节课的重点：分布式缓存的高可用方案。**

在我的项目中，我主要选择的方案有**客户端方案、中间代理层方案和服务端方案**三大类：

- **客户端方案**就是在客户端配置多个缓存的节点，通过缓存写入和读取算法策略来实现分布式，从而提高缓存的可用性。
- **中间代理层方案**是在应用代码和缓存节点之间增加代理层，客户端所有的写入和读取的请求都通过代理层，而代理层中会内置高可用策略，帮助提升缓存系统的高可用。
- **服务端方案**就是 Redis 2.4 版本后提出的 Redis Sentinel 方案。

掌握这些方案可以帮助你，抵御部分缓存节点故障导致的，缓存命中率下降的影响，增强你的系统的鲁棒性。

**客户端方案**

- 缓存数据如何分片

  一般来讲，分片算法常见的就是 Hash 分片算法和一致性 Hash 分片算法两种。

  <img src="https://gitee.com/yanglu_u/ImgRepository/raw/master/images/20201120093607.jpg" style="zoom: 67%;" />

  存在的问题：

  当增加或者减少缓存节点时，缓存总的节点个数变化造成计算出来的节点发生变化，从而造成缓存失效不可用。

  当然了，用一致性 Hash 算法可以很好地解决增加和删减节点时，命中率下降的问题。

  <img src="https://gitee.com/yanglu_u/ImgRepository/raw/master/images/20201120093612.jpg" style="zoom: 67%;" />

  存在的问题：

  i. 缓存节点在圆环上分布不平均，会造成部分缓存节点的压力较大；当某个节点故障时，这个节点所要承担的所有访问都会被顺移到另一个节点上，会对后面这个节点造成压力。

  ii. 一致性 Hash 算法的脏数据问题。

  如何解决第一个问题？可以在一致性 Hash 算法中引入虚拟节点的概念。

  它将一个缓存节点计算多个 Hash 值分散到圆环的不同位置，这样既实现了数据的平均，而且当某一个节点故障或者退出的时候，它原先承担的 Key 将以更加平均的方式分配到其他节点上，从而避免雪崩的发生。

- Memcached 的主从机制

  Redis 本身支持主从的部署方式，但是 Memcached 并不支持，所以我们今天主要来了解一下 Memcached 的主从机制是如何在客户端实现的。

  在之前的项目中，我就遇到了单个主节点故障导致数据穿透的问题，这时我为每一组 Master 配置一组 Slave，更新数据时主从同步更新。读取时，优先从 Slave 中读数据，如果读取不到数据就穿透到 Master 读取，并且将数据回种到 Slave 中以保持 Slave 数据的热度。

  主从机制最大的优点就是当某一个 Slave 宕机时，还会有 Master 作为兜底，不会有大量请求穿透到数据库的情况发生，提升了缓存系统的高可用性。

  <img src="https://gitee.com/yanglu_u/ImgRepository/raw/master/images/20201120093617.jpg" style="zoom: 67%;" />

- 多副本

  其实，主从方式已经能够解决大部分场景的问题，但是对于极端流量的场景下，一组 Slave 通常来说并不能完全承担所有流量，Slave 网卡带宽可能成为瓶颈。

  为了解决这个问题，我们考虑在 Master/Slave 之前增加一层副本层，整体架构是这样的：

  <img src="https://gitee.com/yanglu_u/ImgRepository/raw/master/images/20201120093622.jpg" style="zoom: 67%;" />

  在这个方案中，当客户端发起查询请求时，请求首先会先从多个副本组中选取一个副本组发起查询，如果查询失败，就继续查询 Master/Slave，并且将查询的结果回种到所有副本组中，避免副本组中脏数据的存在。

  基于成本的考虑，每一个副本组容量比 Master 和 Slave 要小，因此它只存储了更加热的数据。在这套架构中，Master 和 Slave 的请求量会大大减少，为了保证它们存储数据的热度，在实践中我们会把 Master 和 Slave 作为一组副本组使用。

**中间代理层方案**

虽然客户端方案已经能解决大部分的问题，但是只能在单一语言系统之间复用。例如微博使用 Java 语言实现了这么一套逻辑，我使用 PHP 就难以复用，需要重新写一套，很麻烦。**而中间代理层的方案就可以解决这个问题。**你可以将客户端解决方案的经验移植到代理层中，通过通用的协议（如 Redis 协议）来实现在其他语言中的复用。

<img src="https://gitee.com/yanglu_u/ImgRepository/raw/master/images/20201120093626.jpg" style="zoom: 67%;" />

**服务端方案**

Redis 在 2.4 版本中提出了 Redis Sentinel 模式来解决主从 Redis 部署时的高可用问题，它可以在主节点挂了以后自动将从节点提升为主节点，保证整体集群的可用性，整体的架构如下图所示：

<img src="https://gitee.com/yanglu_u/ImgRepository/raw/master/images/20201120093629.jpg" style="zoom: 67%;" />

Redis Sentinel 不属于代理层模式，因为对于缓存的写入和读取请求不会经过 Sentinel 节点。Sentinel 节点在架构上和主从是平级的，是作为管理者存在的，**所以可以认为是在服务端提供的一种高可用方案。**

# 15 | 缓存的使用姿势（三）：缓存穿透了怎么办？

一般来说，我们的核心缓存的命中率要保持在 99% 以上，非核心缓存的命中率也要尽量保证在 90%，如果低于这个标准，那么你可能就需要优化缓存的使用方式了。

**缓存穿透的解决方案**

如果要读取一个用户表中未注册的用户，会发生什么情况呢？按照 Cache Aside 这个策略，我们会先读缓存，再穿透读数据库。由于用户并不存在，所以缓存和数据库中都没有查询到数据，因此也就不会向缓存中回种数据，这样当再次请求这个用户数据的时候还是会再次穿透到数据库。在这种场景下，缓存并不能有效地阻挡请求穿透到数据库上，它的作用就微乎其微了。

那如何解决缓存穿透呢？一般来说我们会有两种解决方案：**回种空值以及使用布隆过滤器。**

- 回种空值

  当我们从数据库中查询到空值或者发生异常时，我们可以向缓存中回种一个空值。

  回种空值虽然能够阻挡大量穿透的请求，但如果有大量获取未注册用户信息的请求，缓存内就会有有大量的空值缓存，也就会浪费缓存的存储空间，如果缓存空间被占满了，还会剔除掉一些已经被缓存的用户信息反而会造成缓存命中率的下降。

  **所以这个方案，我建议你在使用的时候应该评估一下缓存容量是否能够支撑。**如果需要大量的缓存节点来支持，那么就无法通过通过回种空值的方式来解决，这时你可以考虑使用布隆过滤器。

- 使用布隆过滤器

  1970 年布隆提出了一种布隆过滤器的算法，用来判断一个元素是否在一个集合中。这种算法由一个二进制数组和一个 Hash 算法组成。它的基本思路如下：

  我们把集合中的每一个值按照提供的 Hash 算法算出对应的 Hash 值，然后将 Hash 值对数组长度取模后得到需要计入数组的索引值，并且将数组这个位置的值从 0 改成 1。在判断一个元素是否存在于这个集合中时，你只需要将这个元素按照相同的算法计算出索引值，如果这个位置的值为 1 就认为这个元素在集合中，否则则认为不在集合中。

  <img src="https://gitee.com/yanglu_u/ImgRepository/raw/master/images/20201120093645.jpg" style="zoom:67%;" />

  A、B、C 等元素组成了一个集合，元素 D 计算出的 Hash 值所对应的的数组中值是 1，所以可以认为 D 也在集合中。而 F 在数组中的值是 0，所以 F 不在数组中。

  **那么我们如何使用布隆过滤器来解决缓存穿透的问题呢？**

  还是以存储用户信息的表为例进行讲解。首先，我们初始化一个很大的数组，比方说长度为 20 亿的数组，接下来我们选择一个 Hash 算法，然后我们将目前现有的所有用户的 ID 计算出 Hash 值并且映射到这个大数组中，映射位置的值设置为 1，其它值设置为 0。

  新注册的用户除了需要写入到数据库中之外，它也需要依照同样的算法更新布隆过滤器的数组中，相应位置的值。那么当我们需要查询某一个用户的信息时，我们首先查询这个 ID 在布隆过滤器中是否存在，如果不存在就直接返回空值，而不需要继续查询数据库和缓存，这样就可以极大地减少异常查询带来的缓存穿透。

  <img src="https://gitee.com/yanglu_u/ImgRepository/raw/master/images/20201120093649.jpg" style="zoom:67%;" />

  布隆过滤器拥有极高的性能，无论是写入操作还是读取操作，时间复杂度都是 O(1)，是常量值。在空间上，相对于其他数据结构它也有很大的优势，比如，20 亿的数组需要 2000000000/8/1024/1024 = 238M 的空间，而如果使用数组来存储，假设每个用户 ID 占用 4 个字节的空间，那么存储 20 亿用户需要 2000000000 * 4 / 1024 / 1024 = 7600M 的空间，是布隆过滤器的 32 倍。

  布隆过滤器它主要有两个缺陷：

  i. 它在判断元素是否在集合中时是有一定错误几率的，比如它会把不是集合中的元素判断为处在集合中；(使用多个hash算法)

  ii. 不支持删除元素。

  布隆过滤器的误判有一个特点，当布隆过滤器判断元素在集合中时，这个元素可能不在集合中。但是一旦布隆过滤器判断这个元素不在集合中时，它一定不在集合中。




