> 来源极客时间《DDD实战课》--欧创新

# 11 | DDD实践：如何用DDD重构中台业务模型？

**互联网电商平台和传统应用分析**

![image-20230228231838497](https://technotes.oss-cn-shenzhen.aliyuncs.com/2023/202302282318580.png)

这两者在业务功能上会有很多相似和差异，这种相似和差异主要体现在四个方面。

1. 核心能力的重复建设。传统保险核心应用有报价、投保、核保和出单功能，同样在互联网电商平台也有。这就是核心能力的重复建设。
2. 通用能力的重复建设。比如用户、客户等。
3. 业务职能的分离建设。
4. 互联网电商平台和传统核心功能前后完全独立建设。

如何避免重复造轮子？

要避免重复建设，就要理解中台的理念和思想。前面说了“中台是企业级能力复用平台”，“复用”用白话说就是重复使用，就是要避免重复造轮子的事情。

中台的设计思想与“高内聚、低耦合”的设计原则是高度一致的。高内聚是把相关的业务行为聚集在一起，把不相关的行为放在其它地方，如果你要修改某个业务行为，只需要修改一处。

**如何构建中台业务模型？**

1、自顶向下的策略

领域建模过程主要基于业务现状，暂时不考虑系统现状。自顶向下的策略适用于全新的应用系统建设，或旧系统推倒重建的情况。

第一步是将领域分解为子域，子域可以分为核心域、通用域和支撑域；

第二步是对子域建模，划分领域边界，建立领域模型和限界上下文；

第三步则是根据限界上下文进行微服务设计。

![image-20230308224749733](https://technotes.oss-cn-shenzhen.aliyuncs.com/2023/202303082247809.png)

2、自底向上的策略

这种策略是基于业务和系统现状完成领域建模。

这个过程会沉淀公共和复用的业务能力，会将分散的业务模型整合。自底向上策略适用于遗留系统业务模型的演进式重构。

第一步：锁定系统所在业务域，构建领域模型。采用事件风暴，找出领域对象，构建聚合，划分限界上下文，建立领域模型。

![image-20230308225032881](https://technotes.oss-cn-shenzhen.aliyuncs.com/2023/202303082250922.png)

第二步：对齐业务域，构建中台业务模型。中台业务建模时，既要关注领域模型的完备性，也要关注不同渠道敏捷响应市场的要求。

![image-20230308225235084](https://technotes.oss-cn-shenzhen.aliyuncs.com/2023/202303082252118.png)

有了上述这样一个思路，我们就可以开始构建中台业务模型了。下面我以客户为例，来给你讲一下客户中台业务模型的构建过程。

互联网电商客户主要面向个人客户，除了有个人客户信息管理功能外，基于营销目的它还有客户积分功能，因此它的领域模型有个人和积分两个聚合。

最终个人客户的领域模型重构为：个人、归并和视图三个聚合重构为个人领域模型（客户信息管理），评级和积分两个聚合重构为评级积分领域模型（面向个人客户）。到这里我们就完成了个人客户领域模型的构建了。

至此我们就完成了客户中台业务模型的构建了，客户中台构建了个人、团体和评级积分三个领域模型。总结成一句话就是：“分域建模型，找准基准域，划定上下文，聚合重归类。”

第三步：中台归类，根据领域模型设计微服务。

完成中台业务建模后，我们就有了下面这张图。从这张图中我们可以看到总共构建了多少个中台，中台下面有哪些领域模型，哪些中台是通用中台，哪些中台是核心中台，中台的基本信息等等，都一目了然。你根据中台下的领域模型就可以设计微服务了。

![image-20230308225719605](https://technotes.oss-cn-shenzhen.aliyuncs.com/2023/202303082257639.png)

**重构过程中的领域对象**

传统核心客户领域模型重构之前，包含个人、团体和评级三个聚合，每个聚合内部都有自己的聚合根、实体、方法和领域服务等。

![image-20230315214137670](https://technotes.oss-cn-shenzhen.aliyuncs.com/2023/202303152141741.png)

互联网电商客户领域模型重构前包含个人和积分两个聚合，每个聚合包含了自己的领域对象、方法和领域服务等。

![image-20230315214212497](https://technotes.oss-cn-shenzhen.aliyuncs.com/2023/202303152142529.png)

# 12 | 领域建模：如何用事件风暴构建领域模型？

那么我们该采用什么样的方法，才能从错综复杂的业务领域中分析并构建领域模型呢？

**事件风暴需要准备些什么？**

1. 事件风暴的参与者
2. 事件风暴要准备的材料
3. 事件风暴的场地
4. 事件风暴分析的关注点

**如何用事件风暴构建领域模型？**

领域建模的过程主要包括产品愿景、业务场景分析、领域建模和微服务拆分与设计这几个重要阶段。

**总结**

很多开发人员在初次学习 DDD 时，似乎并不太关心领域建模，而只是想学学 DDD 的战术设计思想，快速上手，开发微服务。我想这是对 DDD 的一个误解，这已经偏离了 DDD 的核心设计思想，即先有边界清晰的领域模型，才能设计出清晰的微服务边界，这两个阶段一前一后是刚需，我们不能忽略。

# 13 | 代码模型（上）：如何使用DDD设计微服务代码模型？

上一讲我们完成了领域模型的设计，接下来我们就要开始微服务的设计和落地了。那微服务落地时首先要确定的就是微服务的代码结构，也就是我今天要讲的微服务代码模型。

**DDD 分层架构与微服务代码模型**

![image-20230315220608802](https://technotes.oss-cn-shenzhen.aliyuncs.com/2023/202303152206847.png)

微服务代码模型

微服务一级目录结构

微服务一级目录是按照 DDD 分层架构的分层职责来定义的。

![image-20230315220731541](https://technotes.oss-cn-shenzhen.aliyuncs.com/2023/202303152207578.png)

各层目录结构 -- Interfaces

![image-20230315220823600](https://technotes.oss-cn-shenzhen.aliyuncs.com/2023/202303152208634.png)

- Assembler：实现 DTO 与领域对象之间的相互转换和数据交换。一般来说 Assembler 与 DTO 总是一同出现。
- Dto：它是数据传输的载体，内部不存在任何业务逻辑，我们可以通过 DTO 把内部的领域对象与外界隔离。
- Facade：提供较粗粒度的调用接口，将用户请求委派给一个或多个应用服务进行处理。

应用层 -- application

![image-20230315220956372](https://technotes.oss-cn-shenzhen.aliyuncs.com/2023/202303152209416.png)

领域层 -- domain

![image-20230315221118042](https://technotes.oss-cn-shenzhen.aliyuncs.com/2023/202303152211081.png)

基础层 -- infrastructure

![image-20230315221452634](https://technotes.oss-cn-shenzhen.aliyuncs.com/2023/202303152214671.png)

代码模型总目录结构

![image-20230315221539452](https://technotes.oss-cn-shenzhen.aliyuncs.com/2023/202303152215486.png)

# 14 | 代码模型（下）：如何保证领域模型与代码模型的一致性？

要想完成微服务的设计和落地，除了提取出领域对象（聚合、实体、命令和领域事件等）、建立微服务代码模型外，其实还有一步，也就是我们今天的重点——将领域对象映射到微服务代码模型中。那为什么这一步如此重要呢？

我们需要将领域模型作为微服务设计的输入，对领域对象进行设计和转换，让领域对象与代码对象建立映射关系。

**领域对象的整理**

一个领域模型会包含多个聚合，一个聚合包含多个领域对象。

![image-20230316225911391](https://technotes.oss-cn-shenzhen.aliyuncs.com/2023/202303162259466.png)

**从领域模型到微服务的设计**

这个过程会比事件风暴来的更深入和细致。主要关注内容如下：

- 分析微服务内有哪些服务？
- 服务所在的分层？
- 应用服务由哪些服务组合和编排完成？
- 领域服务包括哪些实体的业务逻辑？
- 采用充血模型的实体有哪些属性和方法？
- 有哪些值对象？
- 哪个实体是聚合根等？

**领域层的领域对象**

> ```
> -- 接口层
> -- 应用层
> -- 领域层
>     |--聚合
>         |--实体：个人客户、地址、电话、银行账号
>         |--事件：客户已创建
>         |--领域服务
>         |--仓储
> -- 基础层
> ```

事件风暴结束时，领域模型聚合内一般会有：聚合、实体、命令和领域事件等领域对象。

在完成故事分析和微服务设计后，微服务的聚合内一般会有：聚合、聚合根、实体、值对象、领域事件、领域服务和仓储等领域对象。

1、设计实体：实体类放在领域层的 Entity 目录结构下。

大多数情况下，领域模型的业务实体与微服务的数据库实体是一一对应的。我们分析个人客户时，还需要有地址、电话和银行账号等实体，它们被聚合根引用。

在分层架构里，实体采用充血模型，在实体类内实现实体的全部业务逻辑。这些不同的实体都有自己的方法和业务行为，比如地址实体有新增和修改地址的方法，银行账号实体有新增和修改银行账号的方法。

2、找出聚合根：聚合根类放在代码模型的 Entity 目录结构下。

聚合根来源于领域模型，在个人客户聚合里，个人客户这个实体是聚合根，它负责管理地址、电话以及银行账号的生命周期。

聚合根是一种特殊的实体，它有自己的属性和方法。聚合根可以实现聚合之间的对象引用，还可以引用聚合内的所有实体。聚合根有自己的实现方法，比如生成客户编码，新增和修改客户信息等方法。

3、设计值对象：值对象类放在代码模型的 Entity 目录结构下。

根据需要将某些实体的某些属性或属性集设计为值对象。在个人客户聚合中，客户拥有客户证件类型，它是以枚举值的形式存在，所以将它设计为值对象。

4、设计领域事件：领域事件的发布和订阅类我建议放在应用层的 Event 目录结构下。

如果领域模型中领域事件会触发下一步的业务操作，我们就需要设计领域事件。首先确定领域事件发生在微服务内还是微服务之间。然后设计事件实体对象，事件的发布和订阅机制，以及事件的处理机制。判断是否需要引入事件总线或消息中间件。

5、设计领域服务：领域服务类放在领域层的 Service 目录结构下。

如果一个业务动作或行为跨多个实体，我们就需要设计领域服务。

6、设计仓储：仓储代码放在领域层的 Repository 目录结构下。

每一个聚合都有一个仓储，仓储主要用来完成数据查询和持久化操作。

> 在 Github 找找 DDD 的落地项目。

**应用层的领域对象**

> ```
> -- 接口层
> -- 应用层
>     |--事件订阅
>     |--应用服务
> -- 领域层
>     |--聚合
>         |--实体：个人客户、地址、电话、银行账号
>         |--事件：客户已创建
>         |--领域服务
>         |--仓储
> -- 基础层
> ```

应用层的主要领域对象是应用服务和事件的发布以及订阅。

在严格分层架构模式下，不允许服务的跨层调用，每个服务只能调用它的下一层服务。服务从下到上依次为：实体方法、领域服务和应用服务。

如果需要实现服务的跨层调用，可以采用服务逐层封装的方式。

![image-20230316230732921](https://technotes.oss-cn-shenzhen.aliyuncs.com/2023/202303162307964.png)

**领域对象与微服务代码对象的映射**

1、典型的领域模型

个人客户领域模型中的个人客户聚合，就是典型的领域模型，从聚合内可以提取出多个实体和值对象以及它的聚合根。

![image-20230316231020742](https://technotes.oss-cn-shenzhen.aliyuncs.com/2023/202303162310795.png)

- 层：定义领域对象位于分层架构中的哪一层，比如：接口层、应用层、领域层以及基础层等。
- 领域对象：领域模型中领域对象的具体名称。
- 领域类型：根据 DDD 知识体系定义的领域对象的类型，包括：限界上下文、聚合、聚合根、实体、值对象、领域事件、应用服务、领域服务和仓储服务等领域类型。
- 依赖的领域对象：根据业务对象依赖或分层调用的依赖关系，建立的领域对象的依赖关系，比如：服务调用依赖、关联对象聚合等。
- 包名：代码模型中的包名，对应领域对象所在的软件包。
- 类名：代码模型中的类名，对应领域对象的类名。
- 方法名：代码模型中的方法名，对应领域对象实现或操作的方法名。

在建立这种映射关系后，我们就可以得到如下图的微服务代码结构了。

![image-20230316231244005](https://technotes.oss-cn-shenzhen.aliyuncs.com/2023/202303162312044.png)

2、非典型领域模型

比如，在个人客户领域模型内有客户归并的聚合，它扫描所有客户，按照身份证号码、电话号码等是否重复的业务规则，判断是否是重复的客户，然后对重复的客户进行归并。这种业务场景你就找不到聚合根。

那对于这类非典型模型，我们怎么办？

# 15 | 演进式的微服务架构

**演进式架构**

Martin Fowler 在提出微服务时，他提到了微服务的一个重要特征——演进式架构。演进式架构就是以支持增量的、非破坏的变更作为第一原则。

那如何判断微服务设计是否合理呢？其实很简单，只需要看它是否满足这样的情形就可以了：随着业务的发展或需求的变更，在不断重新拆分或者组合成新的微服务的过程中，不会大幅增加软件开发和维护的成本，并且这个架构演进的过程是非常轻松、简单的。

这也是微服务设计的重点，就是看微服务设计是否能够支持架构长期、轻松的演进。

**微服务还是小单体？**

有些项目团队在将集中式单体应用拆分为微服务时，首先进行的往往不是建立领域模型，而只是按照业务功能将原来单体应用的一个软件包拆分成多个“微服务”。这些“微服务”内的代码仍然是集中式三层架构的模式，“微服务”内的代码高度耦合，逻辑边界不清晰，这里我们暂且称它为“小单体微服务”。

随着新需求的提出和业务的发展，这些小单体微服务会慢慢膨胀起来。

当有一天你发现这些膨胀了的微服务，有一部分业务功能需要拆分出去，你会发现原来这些看似清晰的微服务，不知不觉已经摇身一变，变成了臃肿的大单体了，而这个大单体内的代码依然是高度耦合且边界不清的。这个时候你就需要一遍又一遍地重复着从大单体向单体微服务重构的过程。

其实啊，这种单体式微服务只定义了一个维度的边界，也就是微服务之间的物理边界，本质上还是单体架构模式。微服务设计时要考虑的不仅仅只有这一个边界，别忘了还要定义好微服务内的逻辑边界和代码边界。

**划分边界**

在 DDD 的设计过程中，我们首先会梳理出业务过程中的用户操作、事件以及外部依赖关系等，根据这些梳理出实体等领域对象。根据实体对象之间的业务关联性，将业务紧密相关的多个实体进行组合形成聚合，聚合之间是第一层边界，称为逻辑边界。

然后，根据业务及语义边界等因素将一个或者多个聚合划定在一个限界上下文内，形成领域模型，限界上下文之间的边界是第二层边界，称为物理边界。

![image-20230317223711438](https://technotes.oss-cn-shenzhen.aliyuncs.com/2023/202303172237535.png)

**微服务边界的作用**

我们将这些边界分为：逻辑边界、物理边界和代码边界。

逻辑边界主要定义同一业务领域或应用内紧密关联的对象所组成的不同聚类的组合之间的边界。

逻辑边界在微服务设计和架构演进中具有非常重要的意义！

随着业务的快速发展，如果某一个微服务遇到了高性能挑战，需要将部分业务能力独立出去，我们就可以以聚合为单位，将聚合代码拆分独立为一个新的微服务，这样就可以很容易地实现微服务的拆分。

![image-20230317214508779](https://technotes.oss-cn-shenzhen.aliyuncs.com/2023/202303172145934.png)

物理边界主要从部署和运行的视角来定义微服务之间的边界。

代码边界主要用于微服务内的不同职能代码之间的隔离。

**正确理解微服务的边界**

按照 DDD 设计出来的逻辑边界和代码边界，让微服务架构演进变得不那么费劲了。

实施过程是否一定要做到逻辑边界与物理边界一致性呢？也就是说聚合是否也一定要设计成微服务呢？

微服务的过度拆分会使软件维护成本上升，比如：集成成本、发布成本、运维成本以及监控和定位问题的成本等。

在项目建设初期，如果你不具备较强的微服务管理能力，那就不宜将微服务拆分过细。当我们具备一定的能力以后，且微服务内部的逻辑和代码边界也很清晰，你就可以随时根据需要，拆分出新的微服务，实现微服务的架构演进了。

# 16 | 各层间在微服务内部如何协作？

我们把微服务看作是一家公司，微服务内部各层就是这家公司的各个部门。那么这些部门是怎么协作，以保证公司的正常运行？

**各层间协作**

我们先来回顾一下分层架构中的服务。按照分层架构设计出来的微服务，其内部有 Facade服务、应用服务、领域服务和基础服务。各层服务的主要功能和职责如下。

- Facade 服务：位于用户接口层，包括接口和实现两部分。用于处理用户发送的 Restful 请求，将请求数据 DTO 组装成 DO，并传递给应用层。

- 应用服务：位于应用层。负责服务的组合、编排和转发，对外提供粗粒度的服务。除了完成服务的组合和编排外，应用服务内还可以完成安全认证、权限校验、初步的数据校验和分布式事务控制等功能。

- 领域服务：位于领域层。领域服务封装核心的业务逻辑，这些业务逻辑往往需要多个实体协作，它对多个实体或方法的业务逻辑进行组合或编排，以领域服务的方式供应用层调用。

  为了实现微服务内聚合之间的解耦，聚合之间的服务调用和数据交互应通过应用服务来完成。原则上我们应该禁止聚合之间的领域服务直接调用和聚合之间的数据表关联。

- 基础服务：位于基础层。提供基础资源服务（比如数据库、缓存等），实现各层的解耦，降低外部资源变化对业务应用逻辑的影响。基础服务主要为仓储服务，领域服务和应用服务都可以调用仓储服务接口，通过仓储服务实现数据持久化。

这些内部服务的调用关系如下图所示。

![image-20230318224150539](https://technotes.oss-cn-shenzhen.aliyuncs.com/2023/202303182241612.png)

微服务架构下往往采用前后端分离的设计模式，前端应用独立部署。前端应用通过 API 网关调用 Facade 服务，Facade 定向到应用服务。根据业务场景需要，应用服务有两种调用路径：

第一，应用服务调用并组装领域服务，领域服务组装实体和实体方法，实现核心领域逻辑。领域服务通过仓储服务获取持久化数据对象，完成实体数据初始化。

第二，应用服务直接调用仓储服务。这种方式主要针对像缓存、文件等类型的基础层数据访问。这类数据主要是查询操作，没有太多的领域逻辑，不经过领域层，不涉及数据库持久化对象。

如果涉及微服务之间的服务调用，往往是通过 API 网关访问。还有一类的调用是通过领域事件驱动。

当应用服务业务逻辑处理完成后，如果发生领域事件，可调用事件发布服务，完成事件发布。当接收到订阅的主题数据时，事件订阅服务会调用事件处理领域服务，完成进一步的业务操作。

**严格分层架构的服务依赖**

服务如果需要跨层调用，下层服务需要在上层封装后，才可以提供跨层服务。也就是说，每一层服务只能向紧邻的上一层提供服务。比如实体方法需要向应用服务提供服务，它需要封装成领域服务。

通过封装你可以避免将核心业务逻辑的实现暴露给外部，将实体和方法封装成领域服务，也可以避免在应用层沉淀过多的本该属于领域层的核心业务逻辑，避免应用层变得臃肿。

举个例子。

![image-20230318230304140](https://technotes.oss-cn-shenzhen.aliyuncs.com/2023/202303182303196.png)

A 实体方法需封装成领域服务 aDomainService 才能暴露给应用服务 aAppService。abDomainService 领域服务组合和封装 A 和 B 实体的方法后，暴露给应用服务 abAppService。

回到开头的比喻，如果把微服务看作是一家公司，各部门是如何协作现在我们已经有了一个较清晰的认识。那如果公司所服务的客户下达了一项需求（类比微服务的一个请求数据），这个需求的是如何在各个部门定义并实现的呢？

**数据的协作与转换**

我们先来看一下微服务内有哪些类型的数据对象。

- 视图对象 VO（View Object），用于封装展示层指定页面或组件的数据。
- 数据传输对象 DTO（Data Transfer Object），用于前端与应用层或者微服务之间的数据组装和传输，是应用之间数据传输的载体。
- 领域对象 DO（Domain Object），微服务运行时的实体，是核心业务的载体。
- 数据持久化对象 PO(Persistent Object)，与数据库结构一一映射，是数据持久化过程中的数据载体。

我们结合下面这张图，看看微服务各层数据对象的职责和转换过程。

![image-20230318221621939](https://technotes.oss-cn-shenzhen.aliyuncs.com/2023/202303182216022.png)

前端应用主要是 VO 对象。展现层使用 VO 进行界面展示，通过用户接口层与应用层采用 DTO 对象进行数据交互。

用户接口层会完成 DO 和 DTO 的互转，完成微服务与前端应用数据交互及转换。Facade 服务会对多个 DO 对象进行组装，转换为 DTO 对象，向前端应用完成数据转换和传输。

应用层的主要对象是 DO 对象。如果需要调用其它微服务的应用服务，DO 会转换为 DTO，完成跨微服务的数据组装和传输。接口层先完成 DTO 到 DO 的转换，然后应用服务接收 DO 进行业务处理。如果 DTO 与 DO 是一对多的关系，这时就需要进行 DO 数据重组。

领域层的主要对象是 DO 对象。DO 是实体和值对象的数据和业务行为载体，承载着基础的核心业务逻辑。通过 DO 和 PO 转换，我们可以完成数据持久化和初始化。

基础层的主要对象是 PO 对象。我们需要先建立 DO 和 PO 的映射关系。当 DO 数据需要持久化时，仓储服务会将 DO 转换为 PO 对象，完成数据库持久化操作。当 DO 数据需要初始化时，仓储服务从数据库获取数据形成 PO 对象，并将 PO 转换为 DO，完成数据初始化。

# 17 | 从后端到前端：微服务后，前端如何设计？



# 18 | 知识点串讲：基于DDD的微服务设计实例

为了更好地理解 DDD 的设计流程，今天我会用一个项目来带你了解 DDD 的战略设计和战术设计，走一遍从领域建模到微服务设计的全过程，一起掌握 DDD 的主要设计流程和关键点。

## **一、项目基本信息**

项目的目标是实现在线请假和考勤管理。功能描述如下：

1. 请假人填写请假单提交审批，根据请假人身份、请假类型和请假天数进行校验，根据审批规则逐级递交上级审批，逐级核批通过则完成审批，否则审批不通过退回申请人。
2. 根据考勤规则，核销请假数据后，对考勤数据进行校验，输出考勤统计。

## **二、战略设计**

战略设计是根据用户旅程分析，找出领域对象和聚合根，对实体和值对象进行聚类组成聚合，划分限界上下文，建立领域模型的过程。

战略设计阶段建议参与人员：领域专家、业务需求方、产品经理、架构师、项目经理、开发经理和测试经理。

战略设计采用的方法是事件风暴，包括：产品愿景、场景分析、领域建模和微服务拆分等几个主要过程。

### 2.1 产品愿景

事件风暴时，所有参与者针对每一个要点，在贴纸上写出自己的意见，贴到白板上。事件风暴主持者会对每个贴纸，讨论并对发散的意见进行收敛和统一，形成下面的产品愿景图。

![image-20240912225057839](https://technotes.oss-cn-shenzhen.aliyuncs.com/2024/202409132331468.png)

我们把这个产品愿景图整理成一段文字就是：

为了满足内外部人员，他们的在线请假、自动考勤统计和外部人员管理的需求，我们建设这个在线请假考勤系统，它是一个在线请假平台，可以自动考勤统计。它可以同时支持内外网请假，同时管理内外部人员请假和定期考勤分析，而不像 HR 系统，只管理内部人员，且只能内网使用。我们的产品内外网皆可使用，可实现内外部人员无差异管理。

> 作为（人员/角色）：内部人员，外部人员
>
> 我想（做什么）：建设这个在线请假考勤系统
>
> 以达到（目的）：在线请假、自动考勤、管理外部人员信息

### 2.2 场景分析

场景分析是从用户视角出发，探索业务领域中的典型场景，产出领域中需要支撑的场景分类、用例操作以及不同子域之间的依赖关系，用以支撑领域建模。

项目团队成员一起用事件风暴分析请假和考勤的用户旅程。根据不同角色的旅程和场景分析，尽可能全面地梳理从前端操作到后端业务逻辑发生的所有操作、命令、领域事件以及外部依赖关系等信息。

下面我就以请假和人员两个场景作为示例。

| 场景一：请假                                                 | 场景二：审批                                                 |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 用户：请假人                                                 | 用户：审批人                                                 |
| 请假人登录系统：从权限微服务获取请假人信息和权限数据，完成登录认证。 | 审批人登录系统：从权限微服务获取审批人信息和权限数据，完成登录认证。 |
| 创建请假单：打开请假页面，选择请假类型和起始时间，录入请假信息。保存并创建请假单，提交请假审批。 | 获取请假单：获取审批人名下请假单，选择请假单。               |
| 修改请假单：查询请假单，打开请假页面，修改请假单，提交请假审批。 | 审批：填写审批意见。                                         |
| 提交审批：获取审批规则，根据审批规则，从人员组织关系中获取审批人，给请假单分配审批人。 | 逐级审批：如果还需要上级审批，根据审批规则，从人员组织关系中获取审批人，给请假单分配审批人。重复以上 4 步。 |
|                                                              | 最后审批人完成审批。                                         |

完成审批后，产生<请假审批已通过>领域事件。后续有两个进一步的业务操作：发送请假审批已通过的通知，通知邮件系统告知请假人；将请假数据发送到考勤以便核销。

![image-20240912231230988](https://technotes.oss-cn-shenzhen.aliyuncs.com/2024/202409122312065.png)

下面这个图是人员组织关系场景分析结果图，详细的分析过程以及考勤的场景分析就不描述了。

![image-20240912232201185](https://technotes.oss-cn-shenzhen.aliyuncs.com/2024/202409122322267.png)

### 2.3 领域建模

领域建模是通过对业务和问题域进行分析，建立领域模型。向上通过限界上下文指导微服务边界设计，向下通过聚合指导实体对象设计。

领域建模是一个收敛的过程，分三步：

- 第一步找出领域==实体和值对象==等领域对象；
- 第二步找出==聚合根==，根据实体、值对象与聚合根的依赖关系，建立聚合；
- 第三步根据业务及语义边界等因素，定义==限界上下文==。

**第一步：找出实体和值对象等领域对象**

根据场景分析，分析并找出发起或产生这些命令或领域事件的实体和值对象。将与实体或值对象有关的命令和事件聚集到实体。

下面这个图是分析后的实体与命令的关系。通过分析，我们找到了：请假单、审批意见、审批规则、人员、组织关系、刷卡明细、考勤明细以及考勤统计等实体和值对象。

![image-20240912232740153](https://technotes.oss-cn-shenzhen.aliyuncs.com/2024/202409122340342.png)

**第二步：定义聚合**

定义聚合前，先找出聚合根。从上面的实体中，我们可以找出“请假单”和“人员”两个聚合根。然后找出与聚合根紧密依赖的实体和值对象。我们发现审批意见、审批规则和请假单紧密关联，组织关系和人员紧密关联。

找出这些实体的关系后，我们发现还有刷卡明细、考勤明细和考勤统计，这几个实体没有聚合根。这种情形在领域建模时你会经常遇到，对于这类场景我们需要分情况特殊处理。

刷卡明细、考勤明细和考勤统计这几个实体，它们之间相互独立，找不出聚合根，不是富领域模型，但它们一起完成考勤业务逻辑，具有很高的业务内聚性。我们将这几个业务关联紧密的实体，放在一个考勤聚合内。在微服务设计时，我们依然采用 DDD 的设计和分析方法。由于没有聚合根来管理聚合内的实体，我们可以用传统的方法来管理实体。

经过分析，我们建立了请假、人员组织关系和考勤三个聚合。其中请假聚合有请假单、审批意见实体和审批规则等值对象。人员组织关系聚合有人员和组织关系等实体。考勤聚合有刷卡明细、考勤明细和考勤统计等实体。

![image-20240912234000844](https://technotes.oss-cn-shenzhen.aliyuncs.com/2024/202409122340915.png)

**第三步：定义限界上下文**

由于人员组织关系聚合与请假聚合，共同完成请假的业务功能，两者在请假的限界上下文内。考勤聚合则单独构成考勤统计限界上下文。因此我们为业务划分请假和考勤统计两个限界上下文，建立请假和考勤两个领域模型。

### 2.4 微服务的拆分

理论上一个限界上下文就可以设计为一个微服务，但还需要综合考虑多种外部因素，比如：职责单一性、敏态与稳态业务分离、非功能性需求（如弹性伸缩、版本发布频率和安全等要求）、软件包大小、团队沟通效率和技术异构等非业务要素。

在这个项目，我们划分微服务主要考虑职责单一性原则。因此根据限界上下文就可以拆分为请假和考勤两个微服务。其中请假微服务包含人员组织关系和请假两个聚合，考勤微服务包含考勤聚合。

到这里，战略设计就结束了。通过战略设计，我们建立了领域模型，划分了微服务边界。下一步就是战术设计了，也就是微服务设计。下面我们以请假微服务为例，讲解其设计过程。

## **三、战术设计**

战术设计是根据领域模型进行微服务设计的过程。这个阶段主要梳理微服务内的领域对象，梳理领域对象之间的关系，确定它们在代码模型和分层架构中的位置，建立领域模型与微服务模型的映射关系，以及服务之间的依赖关系。

战术设计阶段建议参与人员：领域专家、产品经理、架构师、项目经理、开发经理和测试经理等。

战术设计包括以下两个阶段：分析微服务领域对象和设计微服务代码结构。

### 3.1 分析微服务领域对象

1、服务的识别和设计



![image-20240912222622906](https://technotes.oss-cn-shenzhen.aliyuncs.com/2024/202409122226021.png)



<img src="https://technotes.oss-cn-shenzhen.aliyuncs.com/2024/202409122227177.png" alt="image-20240912222721122" style="zoom: 67%;" />



<img src="https://technotes.oss-cn-shenzhen.aliyuncs.com/2024/202409132331248.png" alt="image-20240912222757347" style="zoom:67%;" />



![image-20240912222838201](https://technotes.oss-cn-shenzhen.aliyuncs.com/2024/202409122229150.png)



### 3.2 设计微服务代码结构



应用层代码结构

![image-20240912223001827](https://technotes.oss-cn-shenzhen.aliyuncs.com/2024/202409122230891.png)

领域层代码结构



![image-20240912223047832](https://technotes.oss-cn-shenzhen.aliyuncs.com/2024/202409122232108.png)

## 四、后续的工作

### 4.1 详细设计

在完成领域模型和微服务设计后，我们还需要对微服务进行详细的设计。主要设计以下内容：实体属性、数据库表和字段、实体与数据库表映射、服务参数规约及功能实现等。

### 4.2 代码开发和测试

开发人员只需要按照详细的设计文档和功能要求，找到业务功能对应的代码位置，完成代码开发就可以了。代码开发完成后，开发人员要编写单元测试用例，基于挡板模拟依赖对象完成服务测试。

## 五、总结

DDD 战略设计从事件风暴开始，然后我们要找出实体等领域对象，找出聚合根构建聚合，划分限界上下文，建立领域模型。

战术设计从事件风暴的命令开始，识别和设计服务，建立各层服务的依赖关系，设计微服务内的实体和值对象，找出微服务中所有的领域对象，并建立领域对象与代码对象的映射关系。

这样就可以很好地指导项目团队进行微服务开发和测试了。

# 19 | 总结（一）：微服务设计和拆分要坚持哪些原则？

今天我们来聊聊微服务的设计原则和演进策略。

## 一、微服务的演进策略

在从单体向微服务演进时，演进策略大体分为两种：绞杀者策略和修缮者策略。

**绞杀者策略**

绞杀者策略是一种逐步剥离业务能力，用微服务逐步替代原有单体系统的策略。它对单体系统进行领域建模，根据领域边界，在单体系统之外，将新功能和部分业务能力独立出来，建设独立的微服务。新微服务与单体系统保持松耦合关系。

随着时间的推移，大部分单体系统的功能将被独立为微服务，这样就慢慢绞杀掉了原来的单体系统。

**修缮者策略**

修缮者策略是一种维持原有系统整体能力不变，逐步优化系统整体能力的策略。它是在现有系统的基础上，剥离影响整体业务的部分功能，独立为微服务，比如高性能要求的功能，代码质量不高或者版本发布频率不一致的功能等。

通过这些功能的剥离，我们就可以兼顾整体和局部，解决系统整体不协调的问题。

**另起炉灶**

第三种策略，就是另起炉灶，顾名思义就是将原有的系统推倒重做。建设期间，原有单体系统照常运行，一般会停止开发新需求。而新系统则会组织新的项目团队，按照原有系统的功能域，重新做领域建模，开发新的微服务。在完成数据迁移后，进行新旧系统切换。

> 对于大型核心系统我一般不建议采用这种策略，这是因为系统重构后的不稳定性、大量未知的潜在技术风险和新的开发模式下项目团队磨合等不确定性因素，会导致项目实施难度大大增加。

## 二、不同场景下的领域建模策略

由于企业内情况千差万别，发展历程也不一样，有遗留单体系统的微服务改造，也有全新未知领域的业务建模和系统设计，还有遗留系统局部优化的情况。不同场景下，领域建模的策略也会有差异。下面我们就分几类场景来看看如何进行领域建模。

**新建系统**

新建系统又分为简单和复杂领域建模两种场景。

- 简单领域建模

简单的业务领域，一个领域就是一个小的子域。在这个小的问题域内，领域建模过程相对简单，直接采用事件风暴的方法构建领域模型就可以了。

- 复杂领域建模

对于复杂的业务领域，领域可能需要多级拆分后才能开始领域建模。领域拆分为子域，甚至子域还需要进一步拆分。比如：保险它需要拆分为承保、理赔、收付费和再保等子域，承保子域再拆分为投保、保单管理等子子域。复杂领域如果不做进一步细分，由于问题域太大，领域建模的工程量会非常浩大。你不太容易通过事件风暴，完成一个很大的领域建模，即使勉强完成，效果也不一定好。

对于复杂领域，我们可以分三步来完成领域建模和微服务设计。

第一步，拆分子域建立领域模型

第二步，领域模型微调

第三步，微服务的设计和拆分

**单体遗留系统**

如果我们面对的是一个单体遗留系统，只需要将部分功能独立为微服务，而其余仍为单体，整体保持不变。

比如将面临性能瓶颈的模块拆分为微服务。我们只需要将这一特定功能，理解为一个简单子领域，参考简单领域建模的方式就可以了。在微服务设计中，我们还要考虑新老系统之间服务和业务的兼容，必要时可引入防腐层。

## 三、DDD 使用的误区

下面我们就来聊聊DDD 使用的几个误区。

**误区一：所有的领域都用 DDD**

在资源有限的情况下，应聚焦核心域，建议你先从富领域模型的核心域开始，而不必一下就在全业务域推开。

**误区二：全部采用 DDD 战术设计方法**

不同的设计方法有它的适用环境，我们应选择它最擅长的场景。

DDD 中，聚合根管理聚合内实体数据之间的一致性，这种方法对于新建和修改数据非常有效，比如在修改订单数据时，它可以保证订单总金额与所有商品明细金额的一致。但它并不擅长较大数据量的查询，甚至有延迟加载进而影响效率的问题。

而传统的设计方法，可能一条简单的 SQL 语句就可以很快地解决问题。而很多贫领域模型的业务，比如数据统计和分析，DDD 很多方法可能都用不上，或用得并不顺手，而传统的方法很容易就解决了。

我们应该选择最适合的方法，不只是 DDD 设计方法，当然还应该包括传统的设计方法。这里要以快速、高效解决实际问题为最佳，不要为做 DDD 而做 DDD。

**误区三：重战术设计而轻战略设计**

DDD 是一种从领域建模到微服务落地的全方位的解决方案。

战略设计时构建的领域模型，是微服务设计和开发的输入，领域模型边界划分得清不清晰，领域对象定义得明不明确，会决定微服务的设计和开发质量。没有领域模型的输入，基于 DDD 的微服务的设计和开发将无从谈起。因此我们不仅要重视战术设计，更要重视战略设计。

**误区四：DDD 只适用于微服务**

在 DDD 沉默的二十多年里，其实它一直也被应用在单体应用的设计中。

具体项目实施时，要吸取 DDD 的核心设计思想和理念，结合具体的业务场景和团队技术特点，多种方法组合，灵活运用，用正确的方式解决实际问题。

## 四、微服务设计原则

微服务设计原则中，如高内聚低耦合、复用、单一职责等这些常见的设计原则在此就不赘述了，我主要强调下面这几条：

**第一条：要领域驱动设计，而不是数据驱动设计，也不是界面驱动设计。**

微服务设计首先应建立领域模型，然后才开始微服务的拆分和设计。而不是先定义数据模型和库表结构，也不是前端界面需要什么，就去调整核心领域逻辑代码。在设计时应该将外部需求从外到内逐级消化，尽量降低对核心领域层逻辑的影响。

**第二条：要边界清晰的微服务，而不是泥球小单体。**

微服务上线后其功能和代码也不是一成不变的。随着需求或设计变化，领域模型会迭代，微服务的代码也会分分合合。微服务内聚合之间的领域服务和数据库实体原则上应杜绝相互依赖。你可通过应用服务编排或者事件驱动，实现聚合之间的解耦，以便微服务的架构演进。

**第三条：要职能清晰的分层，而不是什么都放的大箩筐。**

分层架构中各层职能定位清晰，且都只能与其下方的层发生依赖。应用层负责服务的组合和编排，不应有太多的核心业务逻辑，领域层负责核心领域业务逻辑的实现。各层应各司其职，职责边界不要混乱。在服务演进时，应尽量将可复用的能力向下层沉淀。

**第四条：要做自己能 hold 住的微服务，而不是过度拆分的微服务。**

微服务过度拆分必然会带来软件维护成本的上升，比如：集成成本、运维成本、监控和定位问题的成本。企业在微服务转型过程中还需要有云计算、DevOps、自动化监控等能力，而一般企业很难在短时间内提升这些能力，如果项目团队没有这些能力，将很难 hold 住这些微服务。

如果在微服务设计之初按照 DDD 的战略设计方法，定义好了微服务内的逻辑边界，做好了架构的分层，其实我们不必拆分太多的微服务，即使是单体也未尝不可。随着技术积累和能力提升，当我们有了这些能力后，我们可以随时轻松地重组出新的微服务，而这个过程不会花费太多的时间和精力。

## 五、微服务拆分需要考虑哪些因素？



### 5.1 基于领域模型



### 5.2 基于业务需求变化频率



### 5.3 基于应用性能



### 5.4 基于组织架构和团队规模



### 5.5 基于安全边界



### 5.6 基于技术异构等因素





# 20 | 总结（二）：分布式架构关键设计10问



# 结束语 | 所谓高手，就是跨过坑和大海！

DDD 是一个相对复杂的方法体系，它与传统的软件开发模式或者流程存在一定的差异。在实践 DDD 时，我觉得你可能会遇到这样三个大坑，下面我来说一说我的看法。

**1. 业务专家或领域专家的问题**

对于成熟业务的领域建模，我们可以从团队经验丰富的设计或开发人员中，挑选出能够深刻理解业务内涵和业务管理要求的人员，担任领域专家完成领域建模。他们可以利用面向对象的设计经验，更深刻地理解和识别出领域模型的领域对象和业务行为，有助于推进领域模型的设计。

而对于新的创业企业，他们面对的是从来没人做过的全新的业务和领域，没有任何可借鉴的经验，更不要提什么领域专家。对于这种情况，就需要团队一起经过更多次更细致的事件风暴，才能建立领域模型。这种初创业务的领域模型往往需要经过多次迭代才能成型，不要奢望一次就可以建立一个完美的领域模型。

**2. 团队 DDD 的理念和技术能力问题**

完成领域建模和微服务设计后，就要投入开发和测试了。这时你可能会发现一些开发人员，并不理解 DDD 设计方法，不知道什么是聚合、分层以及边界？也不知道服务的依赖以及层与层之间的职责边界是什么？

这样容易出现设计很精妙，而开发很糟糕的状况。遇到这种情况，除了要在项目团队普及 DDD 的知识和设计理念外，你还要让所有的项目成员尽早地参与到领域建模中，事件风暴的过程除了统一团队语言外，还可以让团队成员提前了解领域模型、设计要点和注意事项。

**3. DDD 设计原则问题**

DDD 基于各种考虑，有很多的设计原则，也用到了很多的设计模式。条条框框多了，很多人可能就会被束缚住，总是担心或犹豫这是不是原汁原味的 DDD。其实我们不必追求极致的 DDD，这样做反而会导致过度设计，增加开发复杂度和项目成本。

DDD 的设计原则或模式，是考虑了很多具体场景或者前提的。有的是为了解耦，如边界以及分层，有的则是为了保证数据一致性，如聚合根管理等。在理解了这些设计原则的根本原因后，有些场景你就可以灵活把握设计方法了，你可以突破一些原则，不必受限于条条框框，大胆选择最合适的方法。

