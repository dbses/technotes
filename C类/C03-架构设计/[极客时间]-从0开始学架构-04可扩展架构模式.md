# 32 | 可扩展架构的基本思想和模式

今天我们进入架构可扩展模式的学习，这部分内容包括分层架构、SOA 架构、微服务和微内核等，先来聊聊架构的可扩展模式。

如何避免扩展时改动范围太大，是软件架构可扩展性设计的主要思考点。

**可扩展的基本思想**

可扩展性架构的设计方法很多，但万变不离其宗，所有的可扩展性架构设计，背后的基本思想都可以总结为一个字：拆！

按照不同的思路来拆分软件系统，就会得到不同的架构。常见的拆分思路有如下三种。

- 面向流程拆分：将整个业务流程拆分为几个阶段，每个阶段作为一部分。
- 面向服务拆分：将系统提供的服务拆分，每个服务作为一部分。
- 面向功能拆分：将系统提供的功能拆分，每个功能作为一部分。

我以一个简单的学生信息管理系统为例（几乎每个技术人员读书时都做过这样一个系统），拆分方式是：

- 面向流程拆分

展示层：负责用户页面设计，不同业务有不同的页面。例如，登录页面、注册页面、信息管理页面、安全设置页面等。

业务层：负责具体业务逻辑的处理。例如，登录、注册、信息管理、修改密码等业务。

数据层：负责完成数据访问。例如，增删改查数据库中的数据、记录事件到日志文件等。

存储层：负责数据的存储。例如，关系型数据库 MySQL、缓存系统 Memcache 等。

最终架构如下：

<img src="https://gitee.com/yanglu_u/ImgRepository/raw/master/images/20210202232835.png" alt="image-20210202231359644" style="zoom: 50%;" />

- 面向服务拆分

将系统拆分为注册、登录、信息管理、安全设置等服务，最终架构示意图如下：

![image-20210202232744896](https://gitee.com/yanglu_u/ImgRepository/raw/master/images/20210202232843.png)

- 面向功能拆分

注册服务：提供多种方式进行注册，包括手机号注册、身份证注册、学生邮箱注册三个功能。

登录服务：包括手机号登录、身份证登录、邮箱登录三个功能。

信息管理服务：包括基本信息管理、课程信息管理、成绩信息管理等功能。

安全设置服务：包括修改密码、安全手机、找回密码等功能。

最终架构图如下：

![image-20210202233101210](https://gitee.com/yanglu_u/ImgRepository/raw/master/images/20210202233303.png)

通过学生信息管理系统的案例可以发现，不同的拆分方式，架构图差异很大。不同的拆分方式，本质上决定了系统的扩展方式。

**可扩展方式**

合理的拆分，能够强制保证即使出错，出错的范围也不会太广，影响也不会太大。下面是不同拆分方式应对扩展时的优势。

1. 面向流程拆分

扩展时大部分情况只需要修改某一层或两层。例如学生信息管理系统，如果我们将存储层从 MySQL 扩展为同时支持 MySQL 和 Oracle，那么只需要扩展存储层和数据层即可，展示层和业务层无须变动。

2. 面向服务拆分

对某个服务扩展，或者要增加新的服务时，只需要扩展相关服务即可，无须修改所有的服务。以学生管理系统为例，如果我们需要在注册服务中增加一种“学号注册”功能，则只需要修改“注册服务”和“登录服务”即可，“信息管理服务”和“安全设置”服务无须修改。

3. 面向功能拆分

对某个功能扩展，或者要增加新的功能时，只需要扩展相关功能即可，无须修改所有的服务。以学生管理系统为例，如果我们增加“学号注册”功能，则只需要在系统中增加一个新的功能模块，同时修改“登录功能”模块即可，其他功能都不受影响。

不同的拆分方式，将得到不同的系统架构，典型的可扩展系统架构有：

- 面向流程拆分：分层架构。
- 面向服务拆分：SOA、微服务。
- 面向功能拆分：微内核架构。

当然，这几个系统架构也可以在系统架构设计中进行组合使用。以学生管理系统为例，我们最终可以这样设计架构：

- 整体系统采用面向服务拆分中的“微服务”架构，拆分为“注册服务”“登录服务”“信息管理服务”“安全服务”。
- 其中的“注册服务”子系统本身又是采用面向流程拆分的分层架构。
- “登录服务”子系统采用的是面向功能拆分的“微内核”架构。

**思考题**

规则引擎是常用的一种支持可扩展的方式，按照今天的分析，它属于哪一类？

# 33 | 传统的可扩展架构模式：分层架构和SOA

今天我来介绍传统的可扩展模式，包括分层架构和 SOA。

**分层架构**

根据不同的划分维度和对象，可以得到多种不同的分层架构。

1. C/S 架构、B/S 架构

划分的对象是整个业务系统，划分的维度是用户交互。例如，下面是 C/S 架构结构图。

<img src="https://gitee.com/yanglu_u/ImgRepository/raw/master/images/20210203222441.png" alt="image-20210203222441207" style="zoom:50%;" />

2. MVC 架构、MVP 架构

划分的对象是单个业务子系统，划分的维度是职责。例如，MVC 架构中各层之间是两两交互的：

<img src="https://gitee.com/yanglu_u/ImgRepository/raw/master/images/20210203222610.png" alt="image-20210203222610223" style="zoom:50%;" />

3. 逻辑分层架构

划分的对象可以是单个业务子系统，也可以是整个业务系统，划分的维度也是职责。逻辑分层架构中的层是自顶向下依赖的。例如，下面是 Android 操作系统架构图。

![image-20210203222819777](https://gitee.com/yanglu_u/ImgRepository/raw/master/images/20210203222819.png)

无论采取何种分层维度，分层架构设计最核心的一点就是需要保证各层之间的差异足够清晰，边界足够明显，让人看到架构图后就能看懂整个架构。

分层架构之所以能够较好地支撑系统扩展，本质在于隔离关注点（separation of concerns），即每个层中的组件只会处理本层的逻辑。

分层结构的另外一个特点就是层层传递。传统的 J2EE 4 层架构，收到请求后，必须按照下面的方式传递请求：

![image-20210203223901367](https://gitee.com/yanglu_u/ImgRepository/raw/master/images/20210203223901.png)

分层结构的这种约束，好处在于强制将分层依赖限定为两两依赖，降低了整体系统复杂度。例如，Business Layer 被 Presentation Layer 依赖，自己只依赖 Persistence Layer。

但分层结构的代价就是冗余。如果让 Presentation Layer 直接访问 Persistence Layer，Business Layer 直接访问 Database Layer，这样做就失去了分层架构的意义，也导致后续扩展时无法控制受影响范围，牵一发动全身，无法支持快速扩展。

分层架构另外一个典型的缺点就是性能，因为每一次业务请求都需要穿越所有的架构分层，多少都会有一些性能的浪费。但现在硬件和网络的性能有了质的飞越，分层模式理论上的这点性能损失，在实际应用中可以忽略不计。

**SOA**

SOA 出现的背景是企业内部的 IT 系统重复建设且效率低下，主要体现在：

- 企业各部门有独立的 IT 系统，比如人力资源系统、财务系统、销售系统，这些系统可能都涉及人员管理，各 IT 系统都需要重复开发人员管理的功能。
- 当某个员工离职后，需要分别到上述三个系统中删除员工的权限。
- 随着业务的发展，复杂度越来越高，更多的流程和业务需要多个 IT 系统合作完成。
- 由于各个独立的 IT 系统没有标准的实现方式（例如，人力资源系统用 Java 开发，对外提供 RPC；而财务系统用 C# 开发，对外提供 SOAP 协议），导致每次开发新的流程和业务，都需要协调大量的 IT 系统，同时定制开发，效率很低。

为了应对传统 IT 系统存在的问题，SOA 提出了 3 个关键概念。

1. 服务

所有业务功能都是一项服务，服务就意味着要对外提供开放的能力，当其他系统需要使用这项功能时，无须定制化开发。

2. ESB

ESB 将企业中各个不同的服务连接在一起。因为各个独立的服务是异构的，如果没有统一的标准，则各个异构系统对外提供的接口是各式各样的。SOA 使用 ESB 来屏蔽异构系统对外提供各种不同的接口方式，以此来达到服务间高效的互联互通。

3. 松耦合

松耦合的目的是减少各个服务间的依赖和互相影响。采用 SOA 架构后，各个服务是相互独立运行的，甚至都不清楚某个服务到底有多少对其他服务的依赖。

典型的 SOA 架构样例如下：

![image-20210203221733047](https://gitee.com/yanglu_u/ImgRepository/raw/master/images/20210203221733.png)

SOA 解决了传统 IT 系统重复建设和扩展效率低的问题，但其本身也引入了更多的复杂性。SOA 最广为人诟病的就是 ESB，ESB 需要实现与各种系统间的协议转换、数据转换、透明的动态路由等功能。

现实中的协议有很多种，如 JMS、WS、HTTP、RPC 等，数据格式也有很多种，如 XML、JSON、二进制、HTML 等。ESB 要完成这么多协议和数据格式的互相转换，工作量和复杂度都很大，而且这种转换是需要耗费大量计算性能的，当 ESB 承载的消息太多时，ESB 本身会成为整个系统的性能瓶颈。

**思考题**

为什么互联网企业很少采用 SOA 架构？

# 34 | 深入理解微服务架构：银弹 or 焦油坑？

微服务与 SOA 有什么关系？有什么区别？为何有了 SOA 还要提微服务？

**微服务与 SOA 的关系**

关于 SOA 和微服务的关系和区别，大概分为下面几个典型的观点。

- 微服务是 SOA 的实现方式

这种观点认为 SOA 是一种架构理念，而微服务是 SOA 理念的一种具体实现方法。

<img src="https://gitee.com/yanglu_u/ImgRepository/raw/master/images/20210204222846.png" alt="image-20210204222846572" style="zoom: 50%;" />

- 微服务是去掉 ESB 后的 SOA

这种观点认为传统 SOA 架构最广为人诟病的就是庞大、复杂、低效的 ESB，因此将 ESB 去掉，改为轻量级的 HTTP 实现，就是微服务。

<img src="https://gitee.com/yanglu_u/ImgRepository/raw/master/images/20210204223353.png" alt="image-20210204223353217" style="zoom:50%;" />

- 微服务是一种和 SOA 相似但本质上不同的架构理念

相似点在于下图中交叉的地方，就是两者都关注“服务”。本质上不同的地方在于几个核心理念的差异：是否有 ESB、服务的粒度、架构设计的目标等。

<img src="https://gitee.com/yanglu_u/ImgRepository/raw/master/images/20210204223743.png" alt="image-20210204223742966" style="zoom:50%;" />

通过对比一下 SOA 和微服务的一些具体做法，来看看到底哪一种观点更加符合实际情况。

1. 服务粒度

整体上来说，SOA 的服务粒度要粗一些，而微服务的服务粒度要细一些。例如，对一个大型企业来说，“员工管理系统”就是一个 SOA 架构中的服务；而如果采用微服务架构，则“员工管理系统”会被拆分为更多的服务，比如“员工信息管理”“员工考勤管理”“员工假期管理”和“员工福利管理”等更多服务。

2. 服务通信

SOA 采用了 ESB 作为服务间通信的关键组件，负责服务定义、服务路由、消息转换、消息传递，总体上是重量级的实现。微服务推荐使用统一的协议和格式，例如，RESTful 协议、RPC 协议，无须 ESB 这样的重量级实现。

ESB 既知道每个服务的协议类型（例如，是 RMI 还是 HTTP），又知道每个服务的数据类型（例如，是 XML 还是 JSON），还知道每个数据的格式（例如，是 2017-01-01 还是 01/01/2017），而微服务的“dumb pipes”仅仅做消息传递，对消息格式和内容一无所知。 

3. 服务交付

SOA 对服务的交付并没有特殊要求，因为 SOA 更多考虑的是兼容已有的系统；微服务的架构理念要求“快速交付”，相应地要求采取自动化测试、持续集成、自动化部署等敏捷开发相关的最佳实践。因为系统拆分为微服务后，部署的成本呈指数上升。

4. 应用场景

SOA 更加适合于庞大、复杂、异构的企业级系统，这也是 SOA 诞生的背景。这类系统无法完全推倒重来或者进行大规模的优化和重构，只能采用兼容的方式进行处理，而承担兼容任务的就是 ESB。

微服务更加适合于快速、轻量级、基于 Web 的互联网系统，这类系统业务变化快，需要快速交付；对外接口基本都是提供 HTTP RESTful 风格的接口，无须考虑在接口层进行类似 SOA 的 ESB 那样的处理。

综合上述分析，我将 SOA 和微服务对比如下：

![image-20210204221633167](https://gitee.com/yanglu_u/ImgRepository/raw/master/images/20210204221633.png)

因此，我们可以看到，SOA 和微服务本质上是两种不同的架构设计理念，只是在“服务”这个点上有交集而已，因此两者的关系应该是上面第三种观点。

**微服务的陷阱**

我们看一下微服务具体有哪些坑：

1. 服务划分过细，服务间关系复杂

微服务将系统内的复杂度转移为系统间的复杂度了。从理论的角度来计算，n 个服务的复杂度是 n×(n-1)/2。下图形象了说明了整体复杂度：

<img src="https://gitee.com/yanglu_u/ImgRepository/raw/master/images/20210204225841.png" alt="image-20210204225841906" style="zoom:50%;" /> 

2. 服务数量太多，团队效率急剧下降

这样做给工作效率带来了明显的影响，一个简单的需求开发就需要涉及多个微服务，无论是设计、开发、测试、部署，都需要工程师不停地在不同的服务间切换。

3. 调用链太长，性能下降

一般线上的业务接口之间的调用，平均响应时间大约为 50 毫秒，如果用户的一起请求需要经过 6 次微服务调用，则性能消耗就是 300 毫秒，这在很多高性能业务场景下是难以满足需求的。

4. 调用链太长，问题定位困难

任意微服务的故障都将导致整个业务失败。由于微服务数量较多，且故障存在扩散现象，快速定位到底是哪个微服务故障是一件复杂的事情。

5. 没有自动化支撑，无法快速交付

如果没有相应的自动化系统进行支撑，都是靠人工去操作，那么微服务不但达不到快速交付的目的，甚至还不如一个大而全的系统效率高。

6. 没有服务治理，微服务数量多了后管理混乱

- 服务故障隔离：假设上述例子中的 60 个节点有 5 个节点发生故障了，依赖的微服务如何处理这种情况呢？
- 服务注册和发现：同样是上述的例子，现在我们决定从 60 个节点扩容到 80 个节点，或者将 60 个节点缩减为 40 个节点，新增或者减少的节点如何让依赖的服务知道呢？

# 35 | 微服务架构最佳实践 - 方法篇

今天是微服务架构最佳实践的方法篇。

**服务粒度**

微服务拆分粒度应当遵循“三个火枪手”原则，即一个微服务三个人负责开发。例如，团队最初有 6 个人，那么可以划分为 2 个微服务，随着业务的发展，业务功能越来越多，逻辑越来越复杂，团队扩展到 12 个人，那么我们可以将已有的 2 个微服务进行拆分，变成 4 个微服务。

“三个火枪手”的原则主要应用于微服务设计和开发阶段，如果微服务经过一段时间发展后已经比较稳定，处于维护期了，无须太多的开发，那么每个微服务安排 2 个人维护，每个人都可以维护多个微服务。

**拆分方法**

基于“三个火枪手”的理论，我们可以计算出拆分后合适的服务数量，但具体怎么拆也是有技巧的。

1. 基于业务逻辑拆分

这是最常见的一种拆分方式，将系统中的业务模块按照职责范围识别出来，每个单独的业务模块拆分为一个独立的服务。

2. 基于可扩展拆分

将系统中的业务模块按照稳定性排序，将已经成熟和改动不大的服务拆分为稳定服务，将经常变化和迭代的服务拆分为变动服务。稳定的服务粒度可以粗一些，即使逻辑上没有强关联的服务，也可以放在同一个子系统中；不稳定的服务粒度可以细一些，但也不要太细，始终记住要控制服务的总数量。

3. 基于可靠性拆分

将系统中的业务模块按照优先级排序，将可靠性要求高的核心服务和可靠性要求低的非核心服务拆分开来，然后重点保证核心服务的高可用。

这样拆分带来下面几个好处：

- 避免非核心服务故障影响核心服务

例如，日志上报一般都属于非核心服务。拆分后即使日志上报有问题，也不会影响核心服务。

- 核心服务高可用方案可以更简单

核心服务的功能逻辑拆分后更加简单，存储的数据可能更少，用到的组件也会更少，设计高可用方案也会简单很多。

- 能够降低高可用成本

将核心服务拆分出来后，核心服务占用的机器、带宽等资源少了很多。因此，只针对核心服务做高可用方案，机器、带宽等成本比不拆分要节省较多。

4. 基于性能拆分

将性能要求高或者性能压力大的模块拆分出来，避免性能压力大的服务影响其他服务。例如电商的抢购，性能压力最大的是入口的排队功能，可以将排队功能独立为一个服务。

**基础设施**

微服务基础设施如下图所示：

![image-20210205223820798](https://gitee.com/yanglu_u/ImgRepository/raw/master/images/20210205223820.png)

微服务并没有减少复杂度，而只是将复杂度从 ESB 转移到了基础设施。“服务发现”“服务路由”等其实都是 ESB 的功能，只是在微服务中剥离出来成了独立的基础系统。

通常情况下，我建议按照下面优先级来搭建基础设施：

- 服务发现、服务路由、服务容错：这是最基本的微服务基础设施。

- 接口框架、API 网关：主要是为了提升开发效率，接口框架是提升内部服务的开发效率，API 网关是为了提升与外部服务对接的效率。

- 自动化部署、自动化测试、配置中心：主要是为了提升测试和运维效率。

- 服务监控、服务跟踪、服务安全：主要是为了进一步提升运维效率。

以上 3 和 4 两类基础设施，其重要性会随着微服务节点数量增加而越来越重要，但在微服务节点数量较少的时候，可以通过人工的方式支撑，虽然效率不高，但也基本能够顶住。

# 36 | 微服务架构最佳实践 - 基础设施篇

我来简单介绍一下每个基础设施的主要作用。

**自动化测试**

微服务提倡快速交付，版本周期短，版本更新频繁。因此必须通过自动化测试系统来完成绝大部分测试回归的工作。

自动化测试涵盖的范围包括代码级的单元测试、单个系统级的集成测试、系统间的接口测试，如果因为团队规模和人力的原因无法全面覆盖，至少要做到接口测试自动化。

**自动化部署**

微服务需要部署的节点增加了十几倍，因此需要自动化部署的系统来完成部署操作。

自动化部署系统包括版本管理、资源管理（例如，机器管理、虚拟机管理）、部署操作、回退操作等功能。

**配置中心**

微服务的节点数量非常多，通过人工登录每台机器手工修改，效率低，容易出错。此外，有的运行期配置需要动态修改并且所有节点即时生效。

配置中心包括配置版本管理（例如，同样的微服务，有 10 个节点是给移动用户服务的，有 20 个节点给联通用户服务的，配置项都一样，配置值不一样）、增删改查配置、节点管理、配置同步、配置推送等功能。

**接口框架**

微服务提倡轻量级的通信方式，一般采用统一的接口协议和统一的数据格式。例如，我们指定接口协议为 HTTP/REST，数据格式采用 JSON，并且 JSON 的数据都遵循如下规范。

<img src="https://gitee.com/yanglu_u/ImgRepository/raw/master/images/20210206210616.png" alt="image-20210206210616165" style="zoom:50%;" />

> 如果不指定数据格式，那么有的微服务采用 XML，有的采用 JSON，有的采用键值对。这样每个微服务都要适配几十套接口协议，相当于把 ESB 做的事情转交给微服务自己做了，因此需要统一接口框架。

接口框架不是一个可运行的系统，一般以库或者包的形式提供给所有微服务调用。例如，针对上面的 JSON 样例，可以由某个基础技术团队提供多种不同语言的解析包（Java 包、Python 包、C 库等）。

> 类似于 spi 包。

**API 网关**

如果外部系统想调用系统的某个功能，它不需要也没办法理解这么多微服务的职责分工和边界，它只会关注它需要的能力，而不会关注这个能力应该由哪个微服务提供。

除此以外，外部系统访问系统还涉及安全和权限相关的限制，如果外部系统直接访问某个微服务，则意味着每个微服务都要自己实现安全和权限的功能，这样做不但工作量大，而且都是重复工作。

API 网关是外部系统访问的接口，所有的外部系统接⼊系统都需要通过 API 网关，主要包括接入鉴权（是否允许接入）、权限控制（可以访问哪些功能）、传输加密、请求路由、流量控制等功能。

**服务发现**

微服务种类和数量很多，如果这些信息（例如 IP 地址）全部通过手工配置的方式写入各个微服务节点，则数据量很大；其次，微服务节点经常变化，可能是扩容，也可能是故障处理，还可能是灰度升级。因此，需要一套服务发现的系统来支撑微服务的自动注册和发现。

服务发现主要有两种实现方式：自理式和代理式。

1. 自理式

自理式结构如下：

<img src="https://gitee.com/yanglu_u/ImgRepository/raw/master/images/20210206212123.png" alt="image-20210206212123317" style="zoom:50%;" />

自理式结构就是指每个微服务自己完成服务发现。例如，图中 SERVICE INSTANCE A 访问 SERVICE REGISTRY 获取服务注册信息，然后直接访问 SERVICE INSTANCE B。

由于每个微服务都承担了服务发现的功能，访问压力分散到了各个微服务节点，性能和可用性上不存在明显的压力和风险。

2. 代理式

代理式结构如下：

<img src="https://gitee.com/yanglu_u/ImgRepository/raw/master/images/20210206212603.png" alt="image-20210206212603466" style="zoom:50%;" />

代理式结构就是指微服务之间有一个负载均衡系统（图中的 LOAD BALANCER 节点），由负载均衡系统来完成微服务之间的服务发现。

这个方案风险较大。第一个风险是可用性风险，一旦 LOAD BALANCER 系统故障，就会影响所有微服务之间的调用；第二个风险是性能风险，所有的微服务之间的调用流量都要经过 LOAD BALANCER 系统，性能压力会随着微服务数量和流量增加而不断增加，最后成为性能瓶颈。

不管是自理式还是代理式，服务发现的核心功能就是服务注册表，注册表记录了所有的服务节点的配置和状态，每个微服务启动后都需要将自己的信息注册到服务注册表，然后由微服务或者 LOAD BALANCER 系统到服务注册表查询可用服务。

**服务路由**

从所有符合条件的可用微服务节点中挑选出一个具体的节点发起请求，这就是服务路由需要完成的功能。

服务路由和服务发现紧密相关，服务路由一般不会设计成一个独立运行的系统，通常情况下是和服务发现放在一起实现的。对于自理式服务发现，服务路由是微服务内部实现的；对于代理式服务发现，服务路由是由 LOAD BALANCER 系统实现的。无论放在哪里实现，服务路由核心的功能就是路由算法。常见的路由算法有：随机路由、轮询路由、最小压力路由、最小连接数路由等。

**服务容错**

微服务具有故障扩散的特点，如果不及时处理故障，故障扩散开来就会导致看起来系统中很多服务节点都故障了。所以我们需要服务容错的能力。

常见的服务容错包括请求重试、流控和服务隔离。通常情况下，服务容错会集成在服务发现和服务路由系统中。

**服务监控**

系统拆分为微服务后，节点数量大大增加，导致需要监控的机器、网络、进程、接口调用数等监控对象的数量大大增加；同时，一旦发生故障，我们需要快速根据各类信息来定位故障。

服务监控的主要作用有：

- 实时搜集信息并进行分析，避免故障后再来分析，减少了处理时间。
- 服务监控可以在实时分析的基础上进行预警，在问题萌芽的阶段发觉并预警，降低了问题影响的范围和时间。

通常情况下，服务监控需要搜集并分析大量的数据，因此建议做成独立的系统，而不要集成到服务发现、API 网关等系统中。

**服务跟踪**

服务监控可以做到微服务节点级的监控和信息收集，但如果我们需要跟踪某一个请求在微服务中的完整路径，服务监控是难以实现的。因为如果每个服务的完整请求链信息都实时发送给服务监控系统，数据量会大到无法处理。

服务监控和服务跟踪的区别可以简单概括为宏观和微观的区别。例如，A 服务通过 HTTP 协议请求 B 服务 10 次，B 通过 HTTP 返回 JSON 对象，服务监控会记录请求次数、响应时间平均值、响应时间最高值、错误码分布这些信息；而服务跟踪会记录其中某次请求的发起时间、响应时间、响应错误码、请求参数、返回的 JSON 对象等信息。

目前无论是分布式跟踪还是微服务的服务跟踪，绝大部分请求跟踪的实现技术都基于 Google 的 Dapper 论文《Dapper, a Large-Scale Distributed Systems Tracing Infrastructure》。

**服务安全**

从业务的角度来说，部分敏感数据或者操作，只能部分微服务可以访问，而不是所有的微服务都可以访问，因此需要设计服务安全机制来保证业务和数据的安全性。

**思考题**

给你一个由 10 位 Java 高级软件工程师组成的开发团队，采用自研的方式，完成所有的微服务基础设施开发，你预测需要多长时间？理由是什么呢？

答：依据简单原则和演化原则以及“三个火枪手”的人员分配原则，首先可以做API 网关、配置中心、服务发现、服务路由这4部分，经过一个月的开发+半个月的联调的先让基础框架搭建起来，业务能够运行起来。

业务上线后，为了保证用户体验和问题跟踪，在保留一两个留守同学的情况下，开始服务容错、服务监控、服务跟踪这几部分的开发，因为这个阶段中可能还要回头修改已完成的部分让这几个部分配合的更好，联调的工作量也多了不少，这个过程大概要2.5月。

而后随着业务逐渐增多，流量逐渐增加，为避免被黑产“薅羊毛”需要把服务安全部分给完成，同时为了快速响应新的业务需要把接口框架给完成，但此时有些同学会被已完成部分的日常维护、修bug等，这些初步需要两个月时间。

在这里都完成后，可以开始自动化测试、自动化部署这部分，也按照两个月的时间，这样一轮下来总体需要8个月时间。

经过第一轮后微服务的基础实施是有了，但要真正的运作起来还需要经过几轮的迭代才可以，但此时面对老系统的维护新系统的开发整体的进度会变慢不少，这样一个合格的比较完善的微服务基础设施差不多要两年时间了。

# 37 | 微内核架构详解

微内核架构（Microkernel Architecture），也被称为插件化架构（Plug-in Architecture），是一种面向功能进行拆分的可扩展性架构。

**基本架构**

微内核架构包含两类组件：核心系统（core system）和插件模块（plug-in modules）。核心系统负责和具体业务功能无关的通用功能，例如模块加载、模块间通信等；插件模块负责实现具体的业务逻辑。

微内核的基本架构示意图如下：

<img src="https://gitee.com/yanglu_u/ImgRepository/raw/master/images/20210207230750.png" alt="image-20210207230750110" style="zoom:50%;" />

上面这张图中核心系统 Core System 功能比较稳定，不会因为业务功能扩展而不断修改，插件模块可以根据业务功能的需要不断地扩展。微内核的架构本质就是将变化部分封装在插件里面，从而达到快速灵活扩展的目的，而又不影响整体系统的稳定。

**设计关键点**

微内核的核心系统设计的关键技术有：插件管理、插件连接和插件通信。

1. 插件管理

核心系统需要知道当前有哪些插件可用，如何加载这些插件，什么时候加载插件。常见的实现方法是插件注册表机制。

核心系统提供插件注册表（可以是配置文件，也可以是代码，还可以是数据库），插件注册表含有每个插件模块的信息，包括它的名字、位置、加载时机（启动就加载，还是按需加载）等。

2. 插件连接

插件连接指插件如何连接到核心系统。通常来说，核心系统必须制定插件和核心系统的连接规范，然后插件按照规范实现，核心系统按照规范加载即可。

常见的连接机制有 OSGi（Eclipse 使用）、消息模式、依赖注入（Spring 使用），甚至使用分布式的协议都是可以的，比如 RPC 或者 HTTP Web 的方式。

3. 插件通信

由于插件之间没有直接联系，通信必须通过核心系统，因此核心系统需要提供插件通信机制。这种情况和计算机类似，计算机的 CPU、硬盘、内存、网卡是独立设计的配件，但计算机运行过程中，CPU 和内存、内存和硬盘肯定是有通信的，计算机通过主板上的总线提供了这些组件之间的通信功能。

**OSGi 架构简析**

OSGi 的全称是 Open Services Gateway initiative，本身其实是指 OSGi Alliance。它是一个非盈利的国际组织，旨在建立一个开放的服务规范。现在我们谈到 OSGi，如果没有特别说明，一般都是指 OSGi 的规范。

OSGi 框架的逻辑架构图如下：

<img src="https://gitee.com/yanglu_u/ImgRepository/raw/master/images/20210207232319.png" alt="image-20210207232319644" style="zoom: 50%;" />

1. 模块层（Module 层）

模块层实现插件管理功能。OSGi 中，插件被称为 Bundle，每个 Bundle 是一个 Java 的 JAR 文件，每个 Bundle 里面都包含一个元数据文件 MANIFEST.MF，这个文件包含了 Bundle 的基本信息。例如，Bundle 的名称、描述、开发商、classpath，以及需要导入的包和输出的包等，OSGi 核心系统会将这些信息加载到系统中用于后续使用。

一个简单的 MANIFEST.MF 样例如下：

```makefile
// MANIFEST.MF 
Bundle-ManifestVersion: 2 
Bundle-Name:UserRegister
Bundle-SymbolicName: com.test.userregister 
Bundle-Version: 1.0 
Bundle-Activator: com.test.UserRegisterActivator

Import-Package: org.log4j;version="2.0", 
..... 
Export-Package: com.test.userregister;version="1.0", 
```

2. 生命周期层（Lifecycle 层）

生命周期层实现插件连接功能，提供了执行时模块管理、模块对底层 OSGi 框架的访问。生命周期层精确地定义了 Bundle 生命周期的操作（安装、更新、启动、停止、卸载），Bundle 必须按照规范实现各个操作。例如：

```java
public class UserRegisterActivator implements BundleActivator {

  public void start(BundleContext context) {
    UserRegister.instance = new UserRegister (); 
  } 

  public void stop(BundleContext context) { 
    UserRegister.instance = null; 
  } 
}
```

3. 服务层（Service 层）

OSGi 提供了一个服务注册的功能，用于各个插件将自己能提供的服务注册到 OSGi 核心的服务注册中心，如果某个服务想用其他服务，则直接在服务注册中心搜索可用服务中心就可以了。

例如：

```java
// 注册服务
public class UserRegisterActivator implements BundleActivator {
  
  // 在 start() 中用 BundleContext.registerService() 注册服务
  public void start(BundleContext context) {
    context.registerService(UserRegister.class.getName(), new UserRegisterImpl(), null);
  }
  
  // 无须在 stop() 中注销服务，因为 Bundle 停止时会自动注销该 Bundle 中已注册的服务
  public void stop(BundleContext context) {}
  
}

// 检索服务
public class Client implements BundleActivator {
  
  public void start(BundleContext context) {
    // 1. 从服务注册表中检索间接的“服务引用”
    ServiceReference ref = context.getServiceReference(UserRegister.class.getName());
    // 2. 使用“服务引用”去访问服务对象的实例
    ((UserRegister) context.getService(ref)).register();
  }
  
  public void stop(BundleContext context) {}

}
```

注意：这里的服务注册不是插件管理功能中的插件注册，实际上是插件间通信的机制。

**规则引擎架构简析**

规则引擎从结构上来看也属于微内核架构的一种具体实现，其中执行引擎可以看作是微内核，执行引擎解析配置好的业务流，执行其中的条件和规则，通过这种方式来支持业务的灵活多变。

1. 可扩展

通过引入规则引擎，业务逻辑实现与业务系统分离，可以在不改动业务系统的情况下扩展新的业务功能。

2. 易理解

规则通过自然语言描述，业务人员易于理解和操作，而不像代码那样只有程序员才能理解和开发。

3. 高效率

规则引擎系统一般提供可视化的规则定制、审批、查询及管理，方便业务人员快速配置新的业务。

规则引擎的基本架构如下：

<img src="https://gitee.com/yanglu_u/ImgRepository/raw/master/images/20210207225015.png" alt="image-20210207225015191" style="zoom:50%;" />

- 开发人员将业务功能分解提炼为多个规则，将规则保存在规则库中。
- 业务人员根据业务需要，通过将规则排列组合，配置成业务流程，保存在业务库中。
- 规则引擎执行业务流程实现业务功能。

对照微内核架构的设计关键点，我们来看看规则引擎是具体是如何实现的。

1. 插件管理

规则引擎中的规则就是微内核架构的插件，引擎就是微内核架构的内核。规则一般保存在规则库中，通常使用数据库来存储。

2. 插件连接

规则引擎规定了规则开发的语言，业务人员需要基于规则语言来编写规则文件，然后由规则引擎加载执行规则文件来完成业务功能。

3. 插件通信

单个规则并不需要依赖其他规则，因此规则之间没有主动的通信，规则只需要输出数据或者事件，由引擎将数据或者事件传递到下一个规则。

目前最常用的规则引擎是开源的 JBoss Drools，具有下面这些优点：

- 非常活跃的社区支持，以及广泛的应用。
- 快速的执行速度。
- 与 Java Rule Engine API（JSR-94）兼容。
- 提供了基于 Web 的 BRMS——Guvnor，Guvnor 提供了规则管理的知识库，通过它可以实现规则的版本控制，以及规则的在线修改与编译，使得开发人员和系统管理人员可以在线管理业务规则。

下面是一个规则语言编写的规则：

![image-20210207234514396](https://gitee.com/yanglu_u/ImgRepository/raw/master/images/20210207234514.png)

通常情况下需要基于 Drools 进行封装，将规则配置做成可视化的操作，例如下面电商反欺诈的一个示例：

![image-20210207234710891](https://gitee.com/yanglu_u/ImgRepository/raw/master/images/20210207234710.png)

