> 来源极客时间《Redis核心技术与实战》--蒋德钧

# 开篇词

Redis 的坑，总结来说集中在四个方面：

1. CPU 使用上的“坑”，例如数据结构的复杂度、跨 CPU 核的访问；
2. 内存使用上的“坑”，例如主从同步和 AOF 的内存竞争；
3. 存储持久化上的“坑”，例如在 SSD 上做快照的性能抖动；
4. 网络通信上的“坑”，例如多实例时的异常网络丢包。

很多技术人都有一个误区，那就是，只关注零散的技术点，没有建立起一套完整的知识框架，缺乏系统观，但是，系统观其实是至关重要的。

![image-20220212221818462](https://gitee.com/yanglu_u/img2022/raw/master/learn/20220212221818.png)

我梳理了一下这些年遇到的、看到的 Redis 各大典型问题，同时结合相关的技术点，手绘了一张 Redis 的问题画像图。

![image-20220212222044247](https://gitee.com/yanglu_u/img2022/raw/master/learn/20220212222044.png)

无论你遇见什么问题，都可以拿出来这张图。举个例子，如果你遇到了 Redis 的响应变慢问题，对照着这张图，你就可以发现，这个问题和 Redis 的性能主线相关，而性能主线又和数据结构、异步机制、RDB、AOF 重写相关。找到了影响的因素，解决起来也就很容易了。

**课程是如何设计的？**

- 基础篇（1~10）：我会具体讲解数据结构、线程模型、持久化。
- 实践篇（11~37）：我会从“场景”和“案例”两大层面来进行讲解。
  - 数据结构（11~15）
  - 性能和内存（16~22）
  - 缓存（23~27）
  - 锁（28~30）
  - 集群（31~37）
- 未来篇（38~39）：我会向你介绍 Redis 6.0 的新特性，以及当前业界对 Redis 的最新探索，这会让你拥有前瞻性视角。

# 01 | 基本架构：一个键值数据库包含什么？

本节我们通过剖析一个最简单的键值数据库，来迅速抓住学习和调优 Redis 的关键，我把这个简单的键值数据库称为 SimpleKV。

接下来，我们来了解下 SimpleKV 的基本组件。

大体来说，一个键值数据库包括了访问框架、索引模块、操作模块和存储模块四部分。接下来，我们就从这四个部分入手，继续构建我们的 SimpleKV。

![image-20220214212224815](https://gitee.com/yanglu_u/img2022/raw/master/learn/20220214212224.png)

**访问框架：采用什么访问模式？**

访问模式通常有两种：一种是通过函数库调用的方式供外部应用使用，比如，上图中的libsimplekv.so，就是以动态链接库的形式链接到我们自己的程序中，提供键值存储功能；

另一种是通过网络框架以 Socket 通信的形式对外提供键值对操作，这种形式可以提供广泛的键值存储服务。在上图中，我们可以看到，网络框架中包括 Socket Server 和协议解析。

**操作模块：可以对数据做什么操作？**

SimpleKV 需要支持基本操作。

- PUT：新写入或更新一个 key-value 对；
- GET：根据一个 key 读取相应的 value 值；
- DELETE：根据一个 key 删除整个 key-value 对；
- SCAN：查询一个用户在一段时间内的访问记录。

实际业务场景通常还有更加丰富的需求，比如在黑白名单应用中，判断某个用户是否存在，可以增加 EXISTS 操作接口。

SimpleKV 的索引模块负责根据 key 找到相应的 value 的存储位置。对于不同的操作来说，找到存储位置之后，需要进一步执行的操作的具体逻辑会有所差异。

- 对于 GET/SCAN 操作而言，此时根据 value 的存储位置返回 value 值即可；
- 对于 PUT 一个新的键值对数据而言，SimpleKV 需要为该键值对分配内存空间；
- 对于 DELETE 操作，SimpleKV 需要删除键值对，并释放相应的内存空间，这个过程由分配器完成。

**索引模块：如何定位键值对的位置？**

当 SimpleKV 解析了客户端发来的请求，知道了要进行的键值对操作，此时，SimpleKV 需要查找所要操作的键值对是否存在，这依赖于键值数据库的索引模块。

索引的作用是让键值数据库根据 key 找到相应 value 的存储位置，进而执行操作。

**存储模块：可以存哪些数据？**

在 SimpleKV 中，key 是 String 类型，而 value 是基本数据类型，例如 String、整型等。

如何实现重启后快速提供服务呢？

一种方式是，对于每一个键值对，SimpleKV 都对其进行落盘保存，这虽然让 SimpleKV 的数据更加可靠，但是，因为每次都要写盘，SimpleKV 的性能会受到很大影响。

另一种方式是，SimpleKV 只是周期性地把内存中的键值数据保存到文件中，这样可以避免频繁写盘操作的性能影响。但是，一个潜在的代价是 SimpleKV 的数据仍然有丢失的风险。

**总结**

SimpleKV 包含了一个键值数据库的基本组件，为了支持更加丰富的业务场景，Redis 对这些组件或者功能进行了扩展，或者说是进行了精细优化，从而满足了功能和性能等方面的要求。

![image-20220214214942389](https://gitee.com/yanglu_u/img2022/raw/master/learn/20220214214942.png)

# 02 | 数据结构：快速的Redis有哪些慢操作？

Redis 底层数据结构一共有 6 种，分别是简单动态字符串、双向链表、压缩列表、哈希表、跳表和整数数组。它们和数据类型的对应关系如下图所示：

![image-20220217220143729](https://gitee.com/yanglu_u/img2022/raw/master/learn/20220217220143.png)

可以看到，String 类型的底层实现只有一种数据结构，也就是简单动态字符串。而 List、Hash、Set 和 Sorted Set 这四种数据类型，都有两种底层实现结构。通常情况下，我们会把这四种类型称为集合类型。

**键和值用什么结构组织？**

为了实现从键到值的快速访问，Redis 使用了一个哈希表来保存所有键值对。因为这个哈希表保存了所有的键值对，所以，也称为全局哈希表。

在下图中可以看到，哈希桶中的 entry 元素中保存了 \*key 和 \*value 指针，分别指向了实际的键和值。

![image-20220217221113257](https://gitee.com/yanglu_u/img2022/raw/master/learn/20220217221113.png)

我们只需要计算键的哈希值，就可以知道它所对应的哈希桶位置，然后就可以访问相应的 entry 元素。但是，当你往 Redis 中写入大量数据后，就可能发现操作有时候会突然变慢了。这其实是因为你忽略了一个潜在的风险点，那就是哈希表的冲突问题和 rehash 可能带来的操作阻塞。

> 为什么哈希表操作变慢了？--链路过长。

当你往哈希表中写入更多数据时，哈希冲突是不可避免的问题。Redis 解决哈希冲突的方式，就是链式哈希。

![image-20220217214511310](https://gitee.com/yanglu_u/img2022/raw/master/learn/20220217214511.png)

但如果哈希表里写入的数据越来越多，哈希冲突可能也会越来越多，这就会导致某些哈希冲突链过长，进而导致这个链上的元素查找耗时长，效率降低。

> 为什么哈希表操作变慢了？--rehash 拷贝阻塞。

所以，Redis 会对哈希表做 rehash 操作。Redis 默认使用了两个全局哈希表：哈希表 1 和哈希表 2。一开始，当你刚插入数据时，默认使用哈希表 1，此时的哈希表 2 并没有被分配空间。随着数据逐步增多，Redis 开始执行 rehash，这个过程分为三步：

1. 给哈希表 2 分配更大的空间，例如是当前哈希表 1 大小的两倍；
2.  把哈希表 1 中的数据重新映射并拷贝到哈希表 2 中；
3. 释放哈希表 1 的空间，留作下一次 rehash 扩容备用。

到此，我们就可以从哈希表 1 切换到哈希表 2，用增大的哈希表 2 保存更多数据。

这个过程看似简单，但是第二步涉及大量的数据拷贝，如果一次性把哈希表 1 中的数据都迁移完，会造成 Redis 线程阻塞，无法服务其他请求。此时，Redis 就无法快速访问数据了。为了避免这个问题，Redis 采用了渐进式 rehash。

> 避免慢操作--渐进式 rehash。

简单来说就是在第二步拷贝数据时，Redis 仍然正常处理客户端请求，每处理一个请求时，从哈希表 1 中的第一个索引位置开始，顺带着将这个索引位置上的所有 entries 拷贝到哈希表 2 中；等处理下一个请求时，再顺带拷贝哈希表 1 中的下一个索引位置的 entries。如下图所示：

![image-20220217214803853](https://gitee.com/yanglu_u/img2022/raw/master/learn/20220217214803.png)

这样就巧妙地把一次性大量拷贝的开销，分摊到了多次处理请求的过程中，避免了耗时操作，保证了数据的快速访问。

**有哪些底层数据结构？**

刚才，我也和你介绍过，集合类型的底层数据结构主要有 5 种：整数数组、双向链表、哈希表、压缩列表和跳表。

- 压缩列表

压缩列表实际上类似于一个数组，数组中的每一个元素都对应保存一个数据。和数组不同的是，压缩列表在表头有三个字段 zlbytes、zltail 和 zllen，分别表示列表长度、列表尾的偏移量和列表中的 entry 个数；压缩列表在表尾还有一个 zlend，表示列表结束。

![image-20220221211852113](https://gitee.com/yanglu_u/img2022/raw/master/learn/20220221211852.png)

在压缩列表中，如果我们要查找定位第一个元素和最后一个元素，可以通过表头三个字段的长度直接定位，复杂度是 O(1)。而查找其他元素时，就没有这么高效了，只能逐个查找，此时的复杂度就是 O(N) 了。

- 跳表

跳表在链表的基础上，增加了多级索引，通过索引位置的几个跳转，实现数据的快速定位，如下图所示：

![image-20220221210646026](https://gitee.com/yanglu_u/img2022/raw/master/learn/20220221210646.png)

当数据量很大时，跳表的查找复杂度就是 O(logN)。

我们现在可以按照查找的时间复杂度给这些数据结构分下类了：

![image-20220221212135368](https://gitee.com/yanglu_u/img2022/raw/master/learn/20220221212135.png)

**不同操作的复杂度**

```
单元素操作是基础；
范围操作非常耗时；
统计操作通常高效；
例外情况只有几个。
```

第一，单元素操作，是指每一种集合类型对单个数据实现的增删改查操作。这些操作的复杂度由集合采用的数据结构决定，例如，Set 类型用哈希表作为底层数据结构时，它的 SADD、SREM、SRANDMEMBER 复杂度也是 O(1)。

这里，有个地方需要注意一下，Set 类型的 SADD 也支持同时增加多个元素。此时，这些操作的复杂度，就是由单个元素操作复杂度和元素个数决定的。例如，HMSET 增加 M 个元素时，复杂度就从 O(1) 变成 O(M) 了。

第二，范围操作，是指集合类型中的遍历操作。可以返回集合中的所有数据，比如 Set 类型的 SMEMBERS，或者返回一个范围内的部分数据，比如 ZSet 类型的 ZRANGE。这类操作的复杂度一般是 O(N)，比较耗时，我们应该尽量避免。

不过，Redis 从 2.8 版本开始提供了 SCAN 系列操作，这类操作实现了渐进式遍历，每次只返回有限数量的数据。这样一来，相比于 HGETALL、SMEMBERS 这类操作来说，就避免了一次性返回所有元素而导致的 Redis 阻塞。

第三，统计操作，是指集合类型对集合中所有元素个数的记录。例如 LLEN 和 SCARD。这类操作复杂度只有 O(1)，这是因为当集合类型采用压缩列表、双向链表、整数数组这些数据结构时，这些结构中专门记录了元素的个数统计，因此可以高效地完成相关操作。

第四，例外情况，是指某些数据结构的特殊记录，例如压缩列表和双向链表都会记录表头和表尾的偏移量。这样一来，对于 List 类型的 LPOP、RPOP、LPUSH、RPUSH 这四个操作来说，它们是在列表的头尾增删元素，这就可以通过偏移量直接定位，所以它们的复杂度也只有 O(1)，可以实现快速操作。





