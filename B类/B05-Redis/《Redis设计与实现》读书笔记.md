本书Redis版本： 3.0

# ==第一部分 数据结构与对象==

# 第2章 简单动态字符串

Redis 没有直接使用 C 语言传统的字符串表示，而是自己构建了一种名为简单动态字符串（Simple dynamic string）的抽象类型，并将 SDS 用作 Redis 的默认字符串表示。

## 2.1 SDS的定义

每个sds.h/sdshdr结构表示一个SDS值： 

```c
struct sdshdr {
    // 记录buf数组中已使用字节的数量
    // 等于SDS所保存字符串的长度
    int len;
    // 记录buf数组中未使用字节的数量
    int free;
    // 字节数组，用于保存字符串
    char buf[];
};
```

![](https://technotes.oss-cn-shenzhen.aliyuncs.com/2021/images/20201120090833.png)

- free 属性的值为 0，表示这个 SDS 没有分配任何未使用空间；
- len 属性的值为 5，表示这个 SDS 保存了一个五字节长的字符串；
- buf 属性是一个 char 类型的数组，数组的前五个字节分别保存了 'R'、'e'、'd'、'i'、's' 五个字符，而最后一个字节则保存了空字符 '\0'。

遵循空字符结尾这一惯例的好处是，SDS可以直接重用一部分C字符串函数库里面的函数。 

## 2.2 SDS与C字符串的区别

![](https://technotes.oss-cn-shenzhen.aliyuncs.com/2021/images/20201120090838.png)

- 2.2.1 常数复杂度获取字符串长度 

  通过使用 SDS 而不是 C 字符串，Redis 将获取字符串长度所需的复杂度从 O(N) 降低到了O(1)，这确保了获取字符串长度的工作不会成为 Redis 的性能瓶颈。 

- 2.2.2 杜绝缓冲区溢出 

  与 C 字符串不同，SDS 的空间分配策略完全杜绝了发生缓冲区溢出的可能性：当 SDS API 需要对 SDS 进行修改时，API 会先检查 SDS 的空间是否满足修改所需的要求，如果不满足的话，API 会自动将 SDS 的空间扩展至执行修改所需的大小，然后才执行实际的修改操作。

- 2.2.3 减少修改字符串时带来的内存重分配次数 

  通过未使用空间，SDS 实现了空间预分配和惰性空间释放两种优化策略。 

  空间预分配：如果对 SDS 进行修改之后，SDS 的长度（也即是 len 属性的值）将小于 1MB，那么程序分配和 len 属性同样大小的未使用空间 ；如果对 SDS 进行修改之后，SDS 的长度将大于等于 1MB，那么程序会分配 1MB 的未使用空间。  

  惰性空间释放：当 SDS 的 API 需要缩短 SDS 保存的
  字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用 free 属性将这些字节的数量记录起来，并等待将来使用。 

- 2.2.4 二进制安全 

  SDS 使用 len 属性的值而不是空字符来判断字符串是否结束。

- 2.2.5 兼容部分 C 字符串函数 

  SDS 的 API 总会将 SDS 保存的数据的末尾设置为空字符，并且总会在为 buf 数组分配空间时多分配一个字节来容纳这个空字符，这是为了让那些保存文本数据的 SDS 可以重用一部分 <string.h> 库定义的函数。 

## 2.3 SDS API

## 2.4 重点回顾

## 2.5 参考资料

# 第3章 链表

## 3.1 链表和链表节点的实现

每个链表节点使用一个 adlist.h/listNode 结构来表示： 

```c
typedef struct listNode {
    // 前置节点
    struct listNode * prev;
    // 后置节点
    struct listNode * next;
    // 节点的值
    void * value;
} listNode;
```

虽然仅仅使用多个listNode结构就可以组成链表，但使用 adlist.h/list 来持有链表的话，操作起来会更方便： 

```c
typedef struct list {
    // 表头节点
    listNode * head;
    // 表尾节点
    listNode * tail;
    // 链表所包含的节点数量
    unsigned long len;
    // 节点值复制函数
    void *(*dup)(void *ptr);
    // 节点值释放函数
    void (*free)(void *ptr);
    // 节点值对比函数
    int (*match)(void *ptr,void *key);
} list;
```

<img src="https://technotes.oss-cn-shenzhen.aliyuncs.com/2021/images/20201120090844.png" style="zoom: 80%;" />

Redis 的链表实现的特性可以总结如下：

- 双端：链表节点带有 prev 和 next 指针，获取某个节点的前置节点和后置节点的复杂度都是O(1)。
- 无环：表头节点的 prev 指针和表尾节点的 next 指针都指向 NULL，对链表的访问以 NULL 为终点。
- 带表头指针和表尾指针：通过 list 结构的 head 指针和 tail 指针，程序获取链表的表头节点和表尾节点的复杂度为 O(1)。
- 带链表长度计数器：程序使用 list 结构的 len 属性来对 list 持有的链表节点进行计数，程序获取链表中节点数量的复杂度为 O(1)。
- 多态：链表节点使用void*指针来保存节点值，并且可以通过list结构的 dup、 free、 match 三个属性为节点值设置类型特定函数，所以链表可以用于保存各种不同类型的值。 

## 3.2 链表和链表节点的API

## 3.3 重点回顾

# 第4章 字典 

## 4.1 字典的实现

Redis 的字典使用哈希表作为底层实现，一个哈希表里面可以有多个哈希表节点，而每个哈希表节点就保存了字典中的一个键值对。

接下来的三个小节将分别介绍 Redis 的哈希表、哈希表节点以及字典的实现。

4.1.1 哈希表

Redis 字典所使用的哈希表由 dict.h/dictht 结构定义： 

```c
typedef struct dictht {
    // 哈希表数组
    dictEntry **table;
    // 哈希表大小
    unsigned long size;
    // 哈希表大小掩码，用于计算索引值
    // 总是等于size-1
    unsigned long sizemask;
    // 该哈希表已有节点的数量
    unsigned long used;
} dictht;
```

table 属性是一个数组，数组中的每个元素都是一个指向 dict.h/dictEntry 结构的指针，每个 dictEntry 结构保存着一个键值对；

size 属性记录了哈希表的大小，也即是 table 数组的大小；

used 属性则记录了哈希表目前键值对的数量；

sizemask 属性的值总是等于 size - 1，这个属性和哈希值一起决定一个键应该被放到 table 数组的哪个索引上面。

下图展示了一个大小为 4 的空哈希表，没有包含任何键值对。

<img src="https://technotes.oss-cn-shenzhen.aliyuncs.com/2021/images/20201120090850.png" style="zoom:80%;" />

- 4.1.2 哈希表节点

  哈希表节点使用dictEntry结构表示，每个dictEntry结构都保存着一个键值对： 

  ```c
  typedef struct dictEntry {
      // 键
      void *key;
      // 值
      // 可以是一个指针，或者是一个uint64_t整数
      // 又或者是一个int64_t整数。
      union {
          void *val;
          uint64_tu64;
          int64_ts64;
      } v;
      // 指向下个哈希表节点，形成链表
      struct dictEntry *next;
  } dictEntry;
  ```

  ![](https://technotes.oss-cn-shenzhen.aliyuncs.com/2021/images/20201120090854.png)

- 4.1.3 字典

  Redis 中的字典由 dict.h/dict 结构表示： 

  ```c
  typedef struct dict {
      // 类型特定函数
      dictType *type;
      // 私有数据
      void *privdata;
      // 哈希表
      dictht ht[2];
      // rehash索引
      // 当rehash不在进行时，值为-1
      in trehashidx; /* rehashing not in progress if rehashidx == -1 */
  } dict;
  ```

## 4.2 哈希算法

## 4.3 解决键冲突

## 4.4 rehash

## 4.5 渐进式rehash

## 4.6 字典API

## 4.7 重点回顾

# 第5章 跳跃表

## 5.1 跳跃表的实现

## 5.2 跳跃表API

## 5.3 重点回顾

# 第6章 整数集合

## 6.1 整数集合的实现

## 6.2 升级

## 6.3 升级的好处

## 6.4 降级

## 6.5 整数集合API

## 6.6 重点回顾

# 第7章 压缩列表

## 7.1 压缩列表的构成

## 7.2 压缩列表节点的构成

## 7.3 连锁更新

## 7.4 压缩列表API

## 7.5 重点回顾

# 第8章 对象

## 8.1 对象的类型与编码

## 8.2 字符串对象

## 8.3 列表对象

## 8.4 哈希对象

## 8.5 集合对象

## 8.6 有序集合对象

## 8.7 类型检查与命令多态

## 8.8 内存回收

## 8.9 对象共享

## 8.10 对象的空转时长

## 8.11 重点回顾



# ==第二部分 单机数据库的实现==

# 第9章 数据库 

## 9.1 服务器中的数据库

Redis 服务器将所有数据库都保存在服务器状态 redis.h/redisServer 结构的db数组中， 每个 redisDb 结构代表一个数据库： 

```c
struct redisServer {
    // ...
    // 一个数组，保存着服务器中的所有数据库
    redisDb *db;
    // 服务器的数据库数量
    int dbnum;
};
```

dbnum属性的值由服务器配置的database选项决定，默认情况下，该选项的值为16，所以Redis服务器默认会创建16个数据库。

![](https://technotes.oss-cn-shenzhen.aliyuncs.com/2021/images/20201120090859.png)

## 9.2 切换数据库

## 9.3 数据库键空间

## 9.4 设置键的生存时间或过期时间

## 9.5 过期键删除策略

## 9.6 Redis的过期键删除策略

## 9.7 AOF、RDB和复制功能对过期键的处理

## 9.8 数据库通知

## 9.9 重点回顾



# 第10章 RDB持久化

本章首先介绍 Redis 服务器保存和载入 RDB 文件的方法，重点说明 SAVE 命令和 BGSAVE 命令的实现方式。  之后，本章会继续介绍 Redis 服务器自动保存功能的实现原理。

## 10.1 RDB文件的创建与载入



- 10.1.1 SAVE命令执行时的服务器状态
- 10.1.2 BGSAVE命令执行时的服务器状态
- 10.1.3 RDB文件载入时的服务器状态



## 10.2 自动间隔性保存



- 10.2.1 设置保存条件

- 10.2.2 dirty计数器和lastsave属性
- 10.2.3 检查保存条件是否满足



## 10.3 RDB文件结构

![](https://technotes.oss-cn-shenzhen.aliyuncs.com/2021/images/20201120090909.jpg)

> 用全大写单词标识常量，用全小写单词标示变量和数据。本章展示的所有 RDB 文件结构图都遵循这一规则。

REDIS 部分保存着 "REDIS" 五个字符，程序可以在载入文件时，快速检查所载入的文件是否是 RDB 文件。

db_version 长度为 4 字节，这个整数记录了 RDB 文件的版本号。

databases 部分包含着零个或任意多个数据库，以及各个数据库中的键值对数据。

EOF 常量的长度为 1 字节，这个常量标识着 RDB 文件正文内容的结束。

check_sum 是一个 8 字节长的无符号整数，保存着一个校验和。

例如：

![](https://technotes.oss-cn-shenzhen.aliyuncs.com/2021/images/20201120090913.jpg)

- 10.3.1 databases部分
- 10.3.2 key_value_pairs部分
- 10.3.3 value的编码



## 10.4 分析RDB文件

我们使用 od 命令来分析 Redis 服务器产生的 RDB 文件。

- 10.4.1 不包含任何键值对的 RDB 文件
- 10.4.2 包含字符串键的 RDB 文件
- 10.4.3 包含带有过期时间的字符串键的 RDB 文件
- 10.4.4 包含一个集合键的 RDB 文件
- 10.4.5 关于分析RDB文件的说明

## 10.5 重点回顾

## 10.6 参考资料

# 第11章 AOF持久化

11.1 AOF持久化的实现
11.2 AOF文件的载入与数据还原
11.3 AOF重写
11.4 重点回顾

# 第12章 事件

## 12.1 文件事件

## 12.2 时间事件

## 12.3 事件的调度与执行

## 12.4 重点回顾

## 12.5 参考资料

# 第13章 客户端

## 13.1 客户端属性

## 13.2 客户端的创建与关闭

## 13.3 重点回顾

# 第14章 服务器

## 14.1 命令请求的执行过程

## 14.2 serverCron函数

## 14.3 初始化服务器

## 14.4 重点回顾

# ==第三部分 多机数据库的实现==

# 第15章 复制

## 15.1 旧版复制功能的实现

## 15.2 旧版复制功能的缺陷

## 15.3 新版复制功能的实现

## 15.4 部分重同步的实现

## 15.5 PSYNC命令的实现

## 15.6 复制的实现

## 15.7 心跳检测

## 15.8 重点回顾

# 第16章 Sentinel

## 16.1 启动并初始化Sentinel

## 16.2 获取主服务器信息

## 16.3 获取从服务器信息

## 16.4 向主服务器和从服务器发送信息

## 16.5 接收来自主服务器和从服务器的频道信息

## 16.6 检测主观下线状态

## 16.7 检查客观下线状态

## 16.8 选举领头Sentinel

## 16.9 故障转移

## 16.10 重点回顾

## 16.11 参考资料

# 第17章 集群

## 17.1 节点

## 17.2 槽指派

## 17.3 在集群中执行命令

## 17.4 重新分片

## 17.5 ASK错误

## 17.6 复制与故障转移

## 17.7 消息

## 17.8 重点回顾

# ==第四部分 独立功能的实现==

# 第18章 发布与订阅

## 18.1 频道的订阅与退订

## 18.2 模式的订阅与退订

## 18.3 发送消息

## 18.4 查看订阅信息

## 18.5 重点回顾

## 18.6 参考资料

# 第19章 事务

## 19.1 事务的实现

## 19.2 WATCH命令的实现

## 19.3 事务的ACID性质

## 19.4 重点回顾

## 19.5 参考资料

# 第20章 Lua脚本

## 20.1 创建并修改Lua环境

## 20.2 Lua环境协作组件

## 20.3 EVAL命令的实现

## 20.4 EVALSHA命令的实现

## 20.5 脚本管理命令的实现

## 20.6 脚本复制

## 20.7 重点回顾

## 20.8 参考资料

# 第21章 排序

## 21.1 SORT命令的实现

## 21.2 ALPHA选项的实现

## 21.3 ASC选项和DESC选项的实现

## 21.4 BY选项的实现

## 21.5 带有ALPHA选项的BY选项的实现

## 21.6 LIMIT选项的实现

## 21.7 GET选项的实现

## 21.8 STORE选项的实现

## 21.9 多个选项的执行顺序

## 21.10 重点回顾

# 第22章 二进制位数组

## 22.1 位数组的表示

## 22.2 GETBIT命令的实现

## 22.3 SETBIT命令的实现

## 22.4 BITCOUNT命令的实现

## 22.5 BITOP命令的实现

## 22.6 重点回顾

## 22.7 参考资料

# 第23章 慢查询日志

## 23.1 慢查询记录的保存

## 23.2 慢查询日志的阅览和删除

## 23.3 添加新日志

## 23.4 重点回顾

## 第24章 监视器

## 24.1 成为监视器

## 24.2 向监视器发送命令信息

## 24.3 重点回顾

