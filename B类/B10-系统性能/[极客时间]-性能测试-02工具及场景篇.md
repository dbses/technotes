# 性能测试-工具及场景篇

> 来自极客时间《性能测试实战30讲》--高楼

# 07丨性能测试工具：如何录制脚本?

对于一个性能测试工具来说，如果能实现以下几大功能，那么就基本上就满足了性能测试工具的功能。

1. 录制或编写脚本功能
2. 参数化功能
3. 关联功能
4. 场景功能
5. 报告生成功能

今天，我们就来看下在性能测试工具中，如何录制脚本。

针对脚本，我们不仅要录制下来，还要了解录制的原理和录制完之后的脚本增强。不然，在场景中还是会遇到各种各样的问题。

**性能工具中的录制功能**

录制功能从原理上来说，分为两种：

1. 本地录制：通过截取并解析与服务器的交互协议包，生成脚本文件。比如说 LoadRunner 调起 IE 的时候，不用修改 IE 的代理设置，就可以直接抓取 HTTP 包，并通过自己的解析器解析成脚本。
2. 代理录制：通过代理服务器设置，转发客户端和服务器的交互协议包，生成脚本文件。JMeter 中的脚本录制功能就是这样做的。

这两者的不同点主要在于操作上。本地录制相对简单，但有些场景受限，比如说操作只能在某台服务器上，但是这台服务器又不允许安装工具；代理录制操作复杂一些，但可以满足更多的场景。

通过这张图，我们可以简单看到代理录制的逻辑：

![image-20211119222323225](https://gitee.com/yanglu_u/ImgRepository/raw/master/images/20211119222323.png)

1. 我们在 IP 为 2.2.2.2 上的主机上，打开一个代理程序，开 81 端口，所有到 81 端口的都转发到 1.1.1.1 的 80 端口。
2. 当 3.3.3.3 主机要访问 1.1.1.1 的的 80 端口，可以通过访问 2.2.2.2 的 81 端口进行转发。

> 这里需要你注意的是，代理是用来转发数据包的，并不是重定向哦。不管是在本机用代理，还是远程用代理，这个逻辑都是不会变的。

**JMeter 的录制功能**

首先打开 JMeter，添加一个线程组，再添加一个 HTTP(S) Test Script Recorder。

![image-20211119222552666](https://gitee.com/yanglu_u/ImgRepository/raw/master/images/20211119222552.png)

这里有几个关键点说明一下：

Target Controller：这里指定录制出的脚本要放到哪里去。如果你想把不同的脚本放到不同的线程组中去，在录制的时候就可以拆分开。

Grouping：分组，这个分组功能很实用。但是如何分组就和具体的目标相关了，这一点下面我们再细说。

点击 start 按钮时，会提示创建一个根 CA 证书。这个证书生成在 bin 目录中，文件名是： ApacheJMeterTemporaryRootCA.crt，七天有效期。这个证书将被用来客户端转发 HTTPS 的请求。与此同时，还有另一个证书在同目录中生成，名字是 proxyserver.jks，这是 JMeter 自己生成的根证书。

![image-20211119222814766](https://gitee.com/yanglu_u/ImgRepository/raw/master/images/20211119222814.png)

前面我们说到了，JMeter 是用代理的方式来录制的。如果服务端用了 SSL 证书，在代理时也要加 SSL 证书，那么代理录制的结构就会变成这样。

![image-20211119222858876](https://gitee.com/yanglu_u/ImgRepository/raw/master/images/20211119222858.png)

我们点击 ok 之后，就会出现这个界面。在这个界面中，只有两个配置项。

Prefix：请求名的前缀。

Create new transaction after request(ms)：一个请求完成之后，如果下一个请求超出了这里设置的时间间隔，就创建一个新的事务。

![image-20211119222958225](https://gitee.com/yanglu_u/ImgRepository/raw/master/images/20211119222958.png)

然后到主机上设置代理。

这里的代理设置，是在需要访问的客户机上。这个客户机，不一定是压力机所在的机器。这里的 localhost，也应该设置的是代理服务所在的主机 IP。

![image-20211119223125513](https://gitee.com/yanglu_u/ImgRepository/raw/master/images/20211119223125.png)

请注意，如果你要设置为录制 HTTPS，还需要做如下两步。

第一步是，浏览器代理要把 Secure Web Proxy(HTTPS) 选择上，同时填上相应的代理 IP 和端口，下图是 macOS 上的图示。

![image-20211119223202175](https://gitee.com/yanglu_u/ImgRepository/raw/master/images/20211119223202.png)

这时仍然录制不了 HTTPS 应用，访问时会出现如下提示：

![image-20211119223232402](https://gitee.com/yanglu_u/ImgRepository/raw/master/images/20211119223232.png)

这时就要在客户端机器上导入上面提到的 ApacheJMeterTemporaryRootCA.crt。我们打开证书管理软件，在 macOS 上是 Keychain Access，Windows 上是 certmgr.msc。

这时，HTTP 和 HTTPS 都会被录制下来。然后在客户机上打开浏览器，访问你的页面，这样就录制到脚本了。

# 08丨案例： 手把手教你编写最简单的性能脚本

**手工编写 HTTP 脚本**

1. 服务端代码逻辑说明

Controller 关键代码如下：

```java
@RestController
@RequestMapping(value = "pa")
public class PAController {
    @Autowired
    private PAService paService;
    // 查询
    @GetMapping("/query/{id}")
    public ResultVO<User> getById(@PathVariable("id") String id) {
        User user = paService.getById(id);
        return ResultVO.<User>builder().success(user).build();
    }
}
```

Service 关键代码如下：

```java
public User getById(String id){
    return mapper.selectByPrimaryKey(id);
}
```

数据库中表的信息如下：

![2](https://gitee.com/yanglu_u/ImgRepository/raw/master/images/20211121082740.png)

2. 编写 JMeter 脚本

- 创建线程组

![1](https://gitee.com/yanglu_u/ImgRepository/raw/master/images/20211121080325.png)

Number of Threads(users)：这是 JMeter 中的线程数，也可以称之为用户数。

Ramp-up Period(in seconds)：递增时间，指的就是上面配置的线程数将在多长时间内会全部递增完。

Loop Count：这个值指的是一个线程中脚本迭代的次数。

Delay Thread creation until needed：JMeter 所有的线程是一开始就创建完成的，只是递增的时候会按照上面的规则递增。如果选择了这个选项，线程只有在需要时才会创
建。

Scheduler Configuration：这里有一句重要的话，If Loop Count is not -1 or Forever, duration will be min(Duration, Loop Count * iteration duration)。举例来说，如果设置了 Loop Count 为 100，而响应时间是 0.1 秒，那么 Loop Count * iteration duration(这个就是响应时间) = 100 * 0.1 = 10秒。即便设置了 Scheduler 的 Duration 为 100 秒，线程仍然会以 10 秒为结束点。

> 有些人不太理解这一点，经常会设置迭代次数，同时又设置 Scheduler 中的 Duration。而对 TPS 来说，就会产生这样的图：
>
> ![image-20211121085135558](https://gitee.com/yanglu_u/ImgRepository/raw/master/images/20211121085135.png)
>
> 场景没执行完，结果 TPS 全掉下去了，于是开始查后端系统，其实和后端没有任何关系。

- 创建 HTTP Sampler

![3](https://gitee.com/yanglu_u/ImgRepository/raw/master/images/20211121085252.png)

接着我们执行脚本，就得到了如下结果：

![4](https://gitee.com/yanglu_u/ImgRepository/raw/master/images/20211121085349.png)

这样一个最简单的 GET 脚本就做好了。

**手工编写 TCP 脚本**

1. 服务端代码逻辑说明

```java
// 启动 serverSocket
ServerSocket serverSocket = new ServerSocket(Constants.PORT);
// 输出服务启动地址
System.out.println(" 服务已启动:"+serverSocket.getLocalSocketAddress().t
// 接收信息并传递给线程池
while(true) {
    Socket socket = serverSocket.accept();
    executor.submit(new Handler(socket));
}
```

2. 编写 JMeter 脚本

首先创建 TCP Sampler。右键点击 Thread Group - Add - Sampler - TCP Sampler 即可创建。

输入配置和要发送的信息。

![5](https://gitee.com/yanglu_u/ImgRepository/raw/master/images/20211121085826.png)

对于创建一个 TCP 协议的 JMeter 脚本来说，简单地说，
过程就是这样的：创建连接 - 发数据 - 关闭连接。这样，这个手工的脚本就完成了。

3. 添加断言

断言指的就是服务器端有一个业务成功的标识，会传递给客户端，客户端判断是否正常接收到了这个标识的过程。

![6](https://gitee.com/yanglu_u/ImgRepository/raw/master/images/20211121090022.png)

4. 长短连接的问题

在 JMeter 中，默认是复用 TCP 连接的，但是在我们这个示例中，服务端并没有保存这个连接。所以，我们应该在脚本中，把下图中的 Re-use connection 给去掉。

![7](https://gitee.com/yanglu_u/ImgRepository/raw/master/images/20211121090213.png)

短连接的时候，必然会产生更多的 TCP 连接的创建和销毁，对性能来说，这会让系统变得缓慢。

# 09丨关联和断言：一动一静，核心都是在取数据

对每一个性能测试工具来说，关联和断言都是应该具备的基本功能。

**关联**

满足如下条件的数据都是需要关联的：

1. 数据是由服务器端生成的；
2. 数据在每一次请求时都是动态变化的；
3. 数据在后续的请求中需要再发送出去。

比如，我们现在用微服务已经非常多了，在 Spring Boot 中有一个 spring-bootstarter-security，默认会提供一个基于 HTTP Basic 认证的安全防护策略。它在登录时会产生一个 CSRF（Cross-Site Request Forgery）值，这个值典型地处于动态变化中。

下面我们来看一下这个值如何处理。首先，录制登录、退出的脚本。操作如下：

![1](https://gitee.com/yanglu_u/ImgRepository/raw/master/images/20211121213215.png)

录出的脚本如下所示：

![2](https://gitee.com/yanglu_u/ImgRepository/raw/master/images/20211121213524.png)

这时直接回放会得到如下结果：

![3](https://gitee.com/yanglu_u/ImgRepository/raw/master/images/20211121213534.png)

这回你会看到提示了，Unauthorized，没权限。在回放的脚本中，我们看到了如下的登录返回信息。

![4](https://gitee.com/yanglu_u/ImgRepository/raw/master/images/20211121213609.png)

同时，在脚本中，我们可以看到登录时会使用到这个值。

![5](https://gitee.com/yanglu_u/ImgRepository/raw/master/images/20211121213618.png)

下面我们就把它关联了。

首先添加 Cookies Manage。JMeter 在处理 CSRF 时，需要添加一个 Cookies manager。如下：

![6](https://gitee.com/yanglu_u/ImgRepository/raw/master/images/20211121213707.png)

这里的 Cookie Policy 一定要选择 compatibility，以兼容不同的 cookie 策略。然后取动态值，在返回 CSRF 值的地方加一个正则表达式提取器来做关联。

![7](https://gitee.com/yanglu_u/ImgRepository/raw/master/images/20211121214050.png)

这里的`<input name="_csrf" type="hidden" value="(.+?)" />`，就是要取出这个动态的变化值，保存到变量 csrfNumber 中去。然后，发送动态值出去，将发送时的 CSRF 值替换成变量。

![8](https://gitee.com/yanglu_u/ImgRepository/raw/master/images/20211121214148.png)

最后，再回放，就会得到如下结果。

![9](https://gitee.com/yanglu_u/ImgRepository/raw/master/images/20211121214200.png)

这样我们就能看到可以正常访问了。

**断言**

在压力工具中，我们已经知道要比对的值是什么了，接下来就看服务端返回的对不对了。下面我们来详细说一下这个逻辑。

先写一个 POST 接口脚本。

![1](https://gitee.com/yanglu_u/ImgRepository/raw/master/images/20211121214415.png)

执行下，看到如下结果：

![2](https://gitee.com/yanglu_u/ImgRepository/raw/master/images/20211121214426.png)

添加断言。

![3](https://gitee.com/yanglu_u/ImgRepository/raw/master/images/20211121214434.png)











